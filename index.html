<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Cam App</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600;700&family=Audiowide&family=Exo+2:wght@100;200;300;400;500;600;700&family=Syncopate:wght@400;700&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <!-- WebRTC adapter for cross-browser compatibility -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <!-- MJPEG Player -->
    <script src="https://cdn.jsdelivr.net/npm/mjpeg-player@1.0.0/mjpeg-player.min.js"></script>
    <!-- RTSP Player via WebRTC -->
    <script src="https://cdn.jsdelivr.net/npm/rtsp-relay@1.7.0/browser/index.min.js"></script>

    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            font-family: 'Rajdhani', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        .app {
            width: 100%;
            max-width: 480px;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* Landing Page Styles */
        .landing-page {
            background-color: #e8f3e9;
            border-radius: clamp(20px, 4vw, 32px);
            padding: clamp(16px, 4vw, 24px);
            display: flex;
            flex-direction: column;
        }

        .security-badge {
            position: absolute;
            top: clamp(32px, 6vw, 48px);
            left: 50%;
            transform: translateX(-50%);
            width: clamp(56px, 10vw, 80px);
            height: clamp(56px, 10vw, 80px);
            border-radius: 50%;
            background-color: #d5e6d7;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .security-badge::before {
            content: '';
            width: clamp(44px, 8vw, 64px);
            height: clamp(44px, 8vw, 64px);
            border-radius: 50%;
            background-color: #c5dcc7;
        }

        .security-badge::after {
            content: '';
            position: absolute;
            width: clamp(32px, 6vw, 48px);
            height: clamp(32px, 6vw, 48px);
            border-radius: 50%;
            background-color: #b5d2b7;
        }

        .security-badge svg {
            position: relative;
            z-index: 1;
            width: clamp(16px, 3vw, 24px);
            height: clamp(16px, 3vw, 24px);
            color: #95b897;
        }

        .landing-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin-top: clamp(60px, 16vw, 96px);
            gap: clamp(16px, 4vw, 24px);
        }

        .camera-image {
            width: 100%;
            height: clamp(120px, 30vw, 192px);
            background-image: url('/placeholder.svg');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .landing-title {
            font-size: clamp(32px, 8vw, 42px);
            font-weight: 800;
            line-height: 1.1;
            letter-spacing: -0.02em;
            font-family: 'Orbitron', sans-serif;
        }

        .landing-subtitle {
            font-size: clamp(12px, 3vw, 14px);
            color: #4b5563;
            font-weight: 500;
            font-family: 'Exo 2', sans-serif;
        }

        .get-started-btn {
            width: 100%;
            background-color: black;
            color: white;
            border: none;
            border-radius: 9999px;
            padding: clamp(12px, 4vw, 16px) clamp(16px, 5vw, 24px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            margin-bottom: 50px;
            box-shadow: 0 clamp(6px, 2vw, 10px) clamp(10px, 3vw, 15px) -3px rgba(0, 0, 0, 0.1), 0 clamp(3px, 1vw, 4px)
                clamp(4px, 2vw, 6px) -2px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            font-family: 'Audiowide', cursive;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .get-started-btn:hover {
            transform: scale(1.05);
        }

        .get-started-btn:active {
            transform: scale(0.95);
        }

        /* Home Page Styles */
        .home-page {
            background-color: white;
            border-radius: clamp(20px, 4vw, 32px);
            padding: clamp(16px, 4vw, 20px);
            display: flex;
            flex-direction: column;
        }

        .home-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: clamp(10px, 3vw, 16px);
            margin-bottom: clamp(16px, 4vw, 24px);
        }

        .cams-connected {
            display: flex;
            align-items: center;
            gap: clamp(4px, 2vw, 8px);
        }

        .cameras-icon {
            width: clamp(24px, 6vw, 32px);
            height: clamp(24px, 6vw, 32px);
            border-radius: 50%;
            background-color: black;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .cameras-icon:hover {
            transform: scale(1.1);
        }

        .cams-connected-text {
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            font-family: 'Exo 2', sans-serif;
        }

        .add-cam-btn {
            width: clamp(24px, 6vw, 32px);
            height: clamp(24px, 6vw, 32px);
            border-radius: 50%;
            background-color: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .add-cam-btn:hover {
            transform: scale(1.1);
        }

        .tabs {
            display: flex;
            gap: clamp(8px, 3vw, 12px);
            margin-bottom: clamp(16px, 5vw, 24px);
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab {
            padding: clamp(4px, 2vw, 6px) clamp(8px, 4vw, 16px);
            border-radius: 9999px;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            white-space: nowrap;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .tab:hover {
            transform: scale(1.05);
        }

        .tab.active {
            background-color: black;
            color: white;
        }

        .tab:not(.active) {
            background-color: #f3f4f6;
            color: black;
        }

        .camera-list {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            position: relative;
        }

        .camera-list::-webkit-scrollbar {
            display: none;
        }

        .camera-list.empty-state::before {
            content: 'No Cameras Found';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(16px, 4vw, 20px);
            color: #999;
            text-align: center;
        }

        .camera-item {
            position: relative;
            aspect-ratio: 4 / 3;
            border-radius: clamp(16px, 4vw, 24px);
            overflow: hidden;
            margin-bottom: clamp(10px, 4vw, 16px);
            box-shadow: 0 clamp(3px, 1vw, 4px) clamp(4px, 2vw, 6px) -1px rgba(0, 0, 0, 0.1),
                0 clamp(2px, 1vw, 3px) clamp(2px, 1vw, 4px) -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            cursor: pointer;
        }

        .camera-item:hover {
            transform: scale(1.02);
        }

        .camera-item img, 
        .camera-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .camera-item .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .camera-item .camera-overlay.motion-detected-overlay::before {
            content: 'Motion Detected';
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(4px, 2vw, 6px) clamp(8px, 4vw, 16px);
            border-radius: 9999px;
            font-size: clamp(12px, 3vw, 14px);
            font-family: 'Audiowide', cursive;
        }

        .camera-item .camera-overlay.camera-off::before {
            content: 'Camera Off';
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(4px, 2vw, 6px) clamp(8px, 4vw, 16px);
            border-radius: 9999px;
            font-size: clamp(12px, 3vw, 14px);
            font-family: 'Audiowide', cursive;

        }

        .camera-info {
            position: absolute;
            bottom: clamp(10px, 3vw, 16px);
            left: clamp(10px, 3vw, 16px);
            right: clamp(10px, 3vw, 16px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .camera-name {
            color: white;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            font-family: 'Exo 2', sans-serif;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }

        .camera-actions {
            display: flex;
            gap: clamp(4px, 2vw, 8px);
        }

        .camera-action-btn {
            width: clamp(24px, 6vw, 32px);
            height: clamp(24px, 6vw, 32px);
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .camera-action-btn:hover {
            transform: scale(1.1);
        }

        .camera-action-btn.recording {
            background-color: red;
        }

        .camera-action-btn.motion-detected {
            background-color: #00BFFF;
        }

        /* Camera Page Styles */
        .camera-page {
            background-color: white;
            border-radius: clamp(20px, 4vw, 32px);
            position: relative;
            overflow: hidden;
        }

        .camera-feed {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .camera-feed.loading::before {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(16px, 4vw, 20px);
            color: #666;
            text-align: center;
        }

        .camera-feed.live::before {
            content: 'Live';
            position: absolute;
            top: clamp(10px, 3vw, 16px);
            left: clamp(10px, 3vw, 16px);
            padding: clamp(4px, 2vw, 6px) clamp(8px, 4vw, 16px);
            border-radius: 9999px;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            color: white;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            font-family: 'Audiowide', cursive;
        }

        .camera-feed.live.live-off::before {
            content: 'Off';
            background-color: rgba(255, 0, 0, 0.8);

        }

        .camera-feed img,
        .camera-feed video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: transform 0.5s ease;
        }

        .camera-header {
            position: absolute;
            top: clamp(10px, 3vw, 16px);
            left: clamp(10px, 3vw, 16px);
            right: clamp(10px, 3vw, 16px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: clamp(20px, 7vw, 32px);
        }

        .back-btn {
            width: clamp(32px, 8vw, 40px);
            height: clamp(32px, 8vw, 40px);
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .back-btn:hover {
            transform: scale(1.1);
        }

        .timer {
            padding: clamp(4px, 2vw, 6px) clamp(8px, 4vw, 16px);
            border-radius: 9999px;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            color: white;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            font-family: 'Audiowide', cursive;
        }

        /* Custom Camera Controls Styles */
        :root {
            --primary-bg: #e0e0e0;
            --button-bg: #d0d0d0;
            --button-shadow: inset 2px 2px 5px #b8b8b8, inset -2px -2px 5px #ffffff;
            --button-active-shadow: inset 2px 2px 5px #b8b8b8, inset -2px -2px 5px #ffffff,
                inset 2px 2px 5px #b8b8b8;
            --text-color: #333333;
            --icon-color: #666666;
        }

        .controls-container {
            position: absolute;
            bottom: clamp(16px, 4vw, 24px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            margin-bottom: 30px;
            align-items: center;
            justify-content: center;
            gap: clamp(10px, 2vw, 20px);
            padding: clamp(10px, 2vw, 20px);
        }

        .d-pad {
            position: relative;
            width: clamp(120px, 25vw, 160px);
            height: clamp(120px, 25vw, 160px);
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 50%;
            box-shadow: var(--button-shadow);
        }

        .d-pad-button {
            position: absolute;
            width: clamp(30px, 8vw, 40px);
            height: clamp(30px, 8vw, 40px);
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #ffffff;
            box-shadow: var(--button-shadow);
            transition: all 0.2s ease;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .d-pad-button:active {
            box-shadow: var(--button-active-shadow);
        }

        .up {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        .right {
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        .down {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        .left {
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        .center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(40px, 8vw, 55px);
            height: clamp(40px, 8vw, 55px);
            background-color: transparent;
            border-radius: 50%;
            box-shadow: var(--button-shadow);
        }

        .side-button {
            width: clamp(36px, 8vw, 48px);
            height: clamp(36px, 8vw, 48px);
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            color: #ffffff;
            box-shadow: var(--button-shadow);
            transition: all 0.2s ease;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .side-button:active {
            box-shadow: var(--button-active-shadow);
        }

        .up::after {
            content: '+';
        }

        .down::after {
            content: '−';
        }

        .left::after {
            content: '<';
        }

        .right::after {
            content: '>';
        }

        /* End Custom Camera Control Styles */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(clamp(-5px, -2vw, -10px));
            }
        }

        .animate-float {
            animation: float 3s ease-in-out infinite;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background-color: white;
            padding: clamp(16px, 4vw, 20px);
            border-radius: clamp(10px, 4vw, 16px);
            max-width: 400px;
            width: 90%;
            position: relative;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: clamp(10px, 3vw, 16px);
        }

        .modal-header h2 {
            font-size: clamp(18px, 4vw, 24px);
            font-family: 'Orbitron', sans-serif;
        }

        .modal-close {
            background-color: transparent;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .modal-close:hover {
            transform: scale(1.1);
        }

        .modal-close svg {
            width: clamp(20px, 6vw, 24px);
            height: clamp(20px, 6vw, 24px);
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: clamp(10px, 4vw, 16px);
        }

        .modal-form input {
            padding: clamp(8px, 3vw, 12px);
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
        }

        .modal-form button {
            background-color: black;
            color: white;
            border: none;
            border-radius: 9999px;
            padding: clamp(8px, 3vw, 12px) clamp(16px, 5vw, 24px);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 500;
            box-shadow: 0 clamp(6px, 2vw, 10px) clamp(10px, 3vw, 15px) -3px rgba(0, 0, 0, 0.1),
                0 clamp(3px, 1vw, 4px) clamp(4px, 2vw, 6px) -2px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            font-family: 'Audiowide', cursive;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .modal-form button:hover {
            transform: scale(1.05);
        }

        .modal-form button:active {
            transform: scale(0.95);
        }

        /* Toast Styles */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1100;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
        }

        .toast.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }

        .toast.hidden {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }

        .toast.success {
            background-color: #4CAF50;
        }

        .toast.error {
            background-color: #F44336;
        }

        .toast.warning {
            background-color: #FF9800;
        }

        .toast.info {
            background-color: #2196F3;
        }

        /* Confirmation Modal Styles */
        .confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .confirmation-modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .confirmation-modal .modal-content {
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;

        }

        .confirmation-modal.active .modal-content {
            transform: translateY(0);
        }

        .confirmation-modal .modal-form {
            display: flex;
            flex-direction: row;
            gap: clamp(10px, 4vw, 16px);
            justify-content: center;
        }

        .confirmation-modal .modal-form button {
            padding: clamp(8px, 3vw, 12px) clamp(16px, 5vw, 24px);
        }


        /* Settings Modal Styles */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .settings-modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .settings-modal .modal-content {
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .settings-modal.active .modal-content {
            transform: translateY(0);
        }

        .settings-modal .modal-form input {
            margin-bottom: clamp(10px, 4vw, 16px);
        }

        .settings-modal .modal-form input[type='checkbox'] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        .settings-modal .modal-form .form-group1 {
            display: flex;
            align-items: center;
            margin-bottom: clamp(10px, 4vw, 16px);
        }

        /* Category Modal Styles */
        #categoryModal .modal-content {
            max-width: 300px;
        }

        #categoryModal .modal-form {
            gap: clamp(10px, 4vw, 16px);
        }

        #categoryModal .modal-form button {
            padding: clamp(8px, 3vw, 12px) clamp(16px, 5vw, 24px);
        }

        #categoryModal .modal-form input {
            margin-bottom: clamp(10px, 4vw, 16px);
        }

        /* Camera item for loading*/
        .camera-item.loading-camera img{
            display: none;
        }
        .camera-item.loading-camera::before {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(16px, 4vw, 20px);
            color: #666;
            text-align: center;
            z-index: 2;
        }

        /* Connection status indicator */
        .connection-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: white;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .connection-status.online {
            background-color: #4CAF50;
            opacity: 1;
        }
        
        .connection-status.offline {
            background-color: #F44336;
            opacity: 1;
        }
        
        .connection-status.reconnecting {
            background-color: #FF9800;
            opacity: 1;
        }

        /* Stream error overlay */
        .stream-error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .stream-error-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .stream-error-overlay button {
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Protocol selector styles */
        .protocol-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            padding: 5px;
            backdrop-filter: blur(5px);
        }
        
        .protocol-selector select {
            background-color: transparent;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            padding: 3px 5px;
            font-size: 12px;
            font-family: 'Exo 2', sans-serif;
        }
        
        .protocol-selector select option {
            background-color: #333;
            color: white;
        }

        /* Media queries for larger screens */
        @media (min-width: 768px) {
            .app {
                max-width: 768px;
            }
        }
        @media (min-width: 1024px) {
            .app {
                max-width: 1024px;
            }
        }

        /* Protocol Selector Styling */
.protocol-selector {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 8px;
    padding: 8px 12px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
}

.protocol-selector select {
    appearance: none;
    background-color: transparent;
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 14px;
    font-family: 'Exo 2', sans-serif;
    outline: none;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
}

/* Custom dropdown arrow */
.protocol-selector {
    position: relative;
}

.protocol-selector::after {
    content: "▼";
    font-size: 12px;
    color: white;
    position: absolute;
    top: 50%;
    right: 12px;
    transform: translateY(-50%);
    pointer-events: none;
}

.protocol-selector select:hover,
.protocol-selector select:focus {
    border-color: white;
}

/* Stream Protocol Form Group */
.form-group {
    display: flex;
    flex-direction: column;
    position: relative;
    margin-top: 15px;
}

.form-group select {
    width: 100%;
    appearance: none;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    padding: 10px;
    font-size: 14px;
    font-family: 'Orbitron', sans-serif;
    transition: border-color 0.3s ease;
    cursor: pointer;
}

/* Custom dropdown arrow for stream protocol */
.form-group {
    position: relative;
}

.form-group::after {
    content: "▼";
    font-size: 12px;
    color: white;
    position: absolute;
    top: 50%;
    right: 12px;
    transform: translateY(-50%);
    pointer-events: none;
}

.form-group select:hover,
.form-group select:focus {
    border-color: white;
}

.form-group label {
    position: absolute;
    top: -10px;
    left: 10px;
    background-color: black;
    color: white;
    font-size: 12px;
    font-family: 'Exo 2', sans-serif;
    padding: 2px 6px;
    border-radius: 4px;
}

.form-group select option {
    background-color: #1a1a1a;
    color: white;
    padding: 5px;
}


    </style>
</head>
<body>
<div class="app">
<div id="landingPage" class="page landing-page">
<div class="security-badge animate-float">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path
d="M20.91 11.12C20.91 16.01 17.36 20.59 12.51 21.93C12.18 22.02 11.82 22.02 11.49 21.93C6.64 20.59 3.09 16.01 3.09 11.12V6.73C3.09 5.91 3.71 4.98 4.48 4.67L10.05 2.39C11.3 1.88 12.71 1.88 13.96 2.39L19.53 4.67C20.29 4.98 20.92 5.91 20.92 6.73V11.12H20.91Z"
stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
</svg>
</div>
<div class="landing-content">
<div class="camera-image"></div>
<div>
<h1 class="landing-title">SECURE<br>YOUR<br>W🌍RLD</h1>
<p class="landing-subtitle">Secure your home with our security CAM</p>
</div>
</div>
<button class="get-started-btn" aria-label="Get Started">
Get Started
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.4301 5.92993L20.5001 11.9999L14.4301 18.0699" stroke="currentColor"
stroke-width="1.5" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round" />
<path d="M3.5 12H20.33" stroke="currentColor" stroke-width="1.5" stroke-miterlimit="10"
stroke-linecap="round" stroke-linejoin="round" />
</svg>
</button>
</div>
<div id="homePage" class="page home-page" style="transform: translateX(100%);">
    <div class="home-header">
        <div class="cams-connected">
            <div class="cameras-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                    xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 7H17L15 4H9L7 7H3V19H21V7Z" stroke="white" stroke-width="1.5"
                        stroke-linecap="round" stroke-linejoin="round" />
                    <circle cx="12" cy="13" r="4" stroke="white" stroke-width="1.5"
                        stroke-linecap="round" stroke-linejoin="round" />
                </svg>
            </div>
            <span class="cams-connected-text" id="connectedCamsCount">0 Cams Connected</span>
        </div>
        <button class="add-cam-btn" id="addCamBtn" aria-label="Add New Camera">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
                xmlns="http://www.w3.org/2000/svg">
                <path d="M6 12H18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"
                    stroke-linejoin="round" />
                <path d="M12 18V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"
                    stroke-linejoin="round" />
            </svg>
        </button>
    </div>
    <div class="tabs" id="cameraTabs">
        <button class="tab active" data-tab="all" aria-label="All Cameras">All</button>
    </div>
    <div class="camera-list" id="cameraList">
    </div>
</div>

<div id="cameraPage" class="page camera-page" style="transform: translateX(100%);">
    <div class="camera-feed" aria-live="polite">
    </div>
    <div class="camera-header">
        <button class="back-btn" aria-label="Back to Camera List">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                xmlns="http://www.w3.org/2000/svg">
                <path d="M15.5 19L8.5 12L15.5 5" stroke="white" stroke-width="1.5" stroke-linecap="round"
                    stroke-linejoin="round" />
            </svg>
        </button>
        <div class="timer" id="cameraTimer" aria-label="Camera Timer">00:00:00</div>
    </div>
    <!-- Protocol selector -->
    <div class="protocol-selector">
        <select id="protocolSelector">
            <option value="auto">Auto</option>
            <option value="hls">HLS</option>
            <option value="rtsp">RTSP</option>
            <option value="webrtc">WebRTC</option>
            <option value="mjpeg">MJPEG</option>
            <option value="http">HTTP</option>
        </select>
    </div>
    <!-- 3D Engraved Camera Controls -->
    <div class="controls-container">
        <button class="side-button mute-btn" data-action="mute" aria-label="Mute Camera">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line id="muteLine" x1="2" y1="2" x2="22" y2="22" style="display:none;"></line>
            </svg>
        </button>
        <div class="d-pad" role="group" aria-label="Camera controls">
            <button class="d-pad-button up" data-action="zoom-in" aria-label="Zoom in"></button>
            <button class="d-pad-button right" data-action="pan-right" aria-label="Pan right"></button>
            <button class="d-pad-button down" data-action="zoom-out" aria-label="Zoom out"></button>
            <button class="d-pad-button left" data-action="pan-left" aria-label="Pan left"></button>
            <div class="center" aria-hidden="true"></div>
        </div>
        <button class="side-button camera-btn" data-action="camera-btn" aria-label="Toggle camera">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path
                    d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z">
                </path>
                <circle cx="12" cy="13" r="4"></circle>
            </svg>
        </button>
    </div>
    <!-- Stream error overlay -->
    <div class="stream-error-overlay" id="streamErrorOverlay">
        <h3>Stream Connection Error</h3>
        <p id="streamErrorMessage">Unable to connect to camera feed</p>
        <button id="retryStreamBtn">Retry Connection</button>
    </div>
</div>

<!-- Modal for adding a new camera -->
<div id="addCameraModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Add Camera</h2>
            <button class="modal-close" id="closeModalBtn" aria-label="Close Modal">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                    xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </button>
        </div>
        <form id="addCameraForm" class="modal-form">
            <input type="text" id="cameraName" placeholder="Camera Name" required aria-label="Camera Name" />
            <input type="text" id="cameraCategory" placeholder="Camera Category" required
                aria-label="Camera Category" />
            <input type="text" id="cameraFeedUrl" placeholder="Camera Feed URL" required
                aria-label="Camera Feed URL" />
            <div class="form-group">
                <select id="streamProtocol">
                    <option value="auto">Auto-detect</option>
                    <option value="hls">HLS (m3u8)</option>
                    <option value="rtsp">RTSP</option>
                    <option value="webrtc">WebRTC</option>
                    <option value="mjpeg">MJPEG</option>
                    <option value="http">HTTP (mp4/webm)</option>
                </select>
                <label for="streamProtocol">Stream Protocol</label>
            </div>
            <button type="submit">Add Camera</button>
        </form>
    </div>
</div>

<!-- Confirmation Modal -->
<div id="confirmationModal" class="confirmation-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Confirmation</h2>
        </div>
        <p style="text-align: center; margin-bottom: 20px;">Are you sure you want to delete this camera?</p>
        <form class="modal-form">
            <button type="button" id="confirmDeleteBtn">Yes</button>
            <button type="button" id="cancelDeleteBtn">No</button>
        </form>
    </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="settings-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Camera Settings</h2>
            <button class="modal-close" id="closeSettingsModalBtn" aria-label="Close Settings Modal">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                    xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </button>
        </div>
        <form id="settingsForm" class="modal-form">
            <input type="text" id="editCameraName" placeholder="Camera Name" required
                aria-label="Edit Camera Name" />
            <input type="text" id="editCameraCategory" placeholder="Camera Category" required
                aria-label="Edit Camera Category" />
            <input type="text" id="editCameraFeedUrl" placeholder="Camera Feed URL" required
                aria-label="Edit Camera Feed URL" />
            <div class="form-group">
                <select id="editStreamProtocol">
                    <option value="auto">Auto-detect</option>
                    <option value="hls">HLS (m3u8)</option>
                    <option value="rtsp">RTSP</option>
                    <option value="webrtc">WebRTC</option>
                    <option value="mjpeg">MJPEG</option>
                    <option value="http">HTTP (mp4/webm)</option>
                </select>
                <label for="editStreamProtocol">Stream Protocol</label>
            </div>
            <div class="form-group1">
                <input type="checkbox" id="editCameraOn" aria-label="Toggle Camera" />
                <label for="editCameraOn">Camera On</label>
            </div>

            <button type="submit">Save Settings</button>
            <button type="button" id="deleteCameraBtn" style="background-color:red;">Delete Camera</button>
        </form>
    </div>
</div>
<!-- Category Modal -->
<div id="categoryModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="categoryModalTitle">Category Options</h2>
            <button class="modal-close" id="closeCategoryModalBtn" aria-label="Close Modal">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                    xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </button>
        </div>
        <form id="categoryForm" class="modal-form">
            <input type="text" id="newCategoryName" placeholder="New Category Name"
                aria-label="New Category Name" />
            <button type="submit" id="renameCategoryBtn">Rename Category</button>
            <button type="button" id="deleteCategoryBtn" style="background-color:red;">Delete
                Category</button>
        </form>
    </div>
</div>
<!-- Toast Notification -->
<div id="toast" class="toast"></div>
<!-- Connection Status Indicator -->
<div id="connectionStatus" class="connection-status">Online</div>
</div>

<script>
// ** Authentication Simulation **
const authToken = localStorage.getItem('authToken') || 'demo-token';
if (!authToken) {
    window.location.href = 'login.html'; // Redirect to a login page
} else if (authToken === 'demo-token') {
    // For demo purposes, set a token
    localStorage.setItem('authToken', 'demo-token');
}

const landingPage = document.getElementById('landingPage');
const homePage = document.getElementById('homePage');
const cameraPage = document.getElementById('cameraPage');
const addCameraModal = document.getElementById('addCameraModal');
const confirmationModal = document.getElementById('confirmationModal');
const settingsModal = document.getElementById('settingsModal');
const getStartedBtn = document.querySelector('.get-started-btn');
const backBtn = document.querySelector('.back-btn');
const cameraListContainer = document.getElementById('cameraList');
const cameraTabs = document.getElementById('cameraTabs');
const connectedCamsCount = document.getElementById('connectedCamsCount');
const cameraTimerDisplay = document.getElementById('cameraTimer');
const addCamBtn = document.getElementById('addCamBtn');
const addCameraForm = document.getElementById('addCameraForm');
const closeModalBtn = document.getElementById('closeModalBtn')
const deleteCameraBtn = document.getElementById('deleteCameraBtn');
const closeSettingsModalBtn = document.getElementById('closeSettingsModalBtn');
const categoryModal = document.getElementById('categoryModal');
const closeCategoryModalBtn = document.getElementById('closeCategoryModalBtn');
const categoryForm = document.getElementById('categoryForm');
const renameCategoryBtn = document.getElementById('renameCategoryBtn');
const deleteCategoryBtn = document.getElementById('deleteCategoryBtn');
const streamErrorOverlay = document.getElementById('streamErrorOverlay');
const streamErrorMessage = document.getElementById('streamErrorMessage');
const retryStreamBtn = document.getElementById('retryStreamBtn');
const connectionStatus = document.getElementById('connectionStatus');
const protocolSelector = document.getElementById('protocolSelector');

const cameraControls = document.querySelector('.controls-container');
const toast = document.getElementById('toast');
const settingsForm = document.getElementById('settingsForm');
const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
let currentCameraData = null;
let currentCategoryEdit = null;
let timerInterval;
let timerSeconds = 0;
let cameraCounter = 1; // Start from 1 for user-added cameras
let isMuted = false;
let currentEditCameraId = null;
let streamRetryCount = 0;
let maxStreamRetries = 3;
let networkStatus = navigator.onLine;
let currentStreamProtocol = 'auto';

// Monitor network status
window.addEventListener('online', updateNetworkStatus);
window.addEventListener('offline', updateNetworkStatus);

function updateNetworkStatus() {
    networkStatus = navigator.onLine;
    if (networkStatus) {
        connectionStatus.textContent = 'Online';
        connectionStatus.className = 'connection-status online';
        setTimeout(() => {
            connectionStatus.className = 'connection-status';
        }, 3000);
    } else {
        connectionStatus.textContent = 'Offline';
        connectionStatus.className = 'connection-status offline';
        showToast('Network connection lost. Some features may not work.', 'error');
    }
}

const dataService = {
    loadCameras() {
        try {
            const savedData = localStorage.getItem('camerasData');
            if (savedData) {
                return JSON.parse(savedData);
            }
            // Return empty object with just the 'all' array if no saved data
            return { all: [] };
        } catch (error) {
            console.error('Error loading cameras:', error);
            showToast('Failed to load cameras.', 'error');
            return { all: [] };
        }
    },
    
    saveCameras(camerasData) {
        try {
            localStorage.setItem('camerasData', JSON.stringify(camerasData));
            return true;
        } catch (error) {
            console.error('Error saving cameras:', error);
            showToast('Failed to save cameras.', 'error');
            return false;
        }
    },
    
    addCamera(camera, camerasData) {
        try {
            // Add to all cameras
            camerasData.all.push(camera);
            
            // Add to category
            if (camerasData[camera.category]) {
                camerasData[camera.category].push(camera);
            } else {
                camerasData[camera.category] = [camera];
            }
            return camerasData;
        } catch (error) {
            console.error('Error adding camera:', error);
            showToast('Failed to add camera.', 'error');
            return camerasData;
        }
    },
    
    deleteCategory(category, camerasData) {
        try {
            if (category === 'all') {
                showToast('Cannot delete the "All" category', 'error');
                return camerasData;
            }
            
            if (camerasData[category]) {
                // Remove cameras in this category from the 'all' array
                camerasData.all = camerasData.all.filter(camera => camera.category !== category);
                // Delete the category
                delete camerasData[category];
                return camerasData;
            }
            return camerasData;
        } catch (error) {
            console.error('Error deleting category:', error);
            showToast('Failed to delete category.', 'error');
            return camerasData;
        }
    },
    
    removeCameraFromCategory(cameraId, category, camerasData) {
        try {
            if (category === 'all') {
                showToast('Cannot remove from the "All" category', 'error');
                return camerasData;
            }
            
            const categoryIndex = camerasData[category].findIndex(cam => cam.id === cameraId);
            if (categoryIndex > -1) {
                camerasData[category].splice(categoryIndex, 1);
                if (camerasData[category].length === 0) {
                    delete camerasData[category];
                }
                return camerasData;
            }
            return camerasData;
        } catch (error) {
            console.error('Error removing from category:', error);
            showToast('Failed to remove from category.', 'error');
            return camerasData;
        }
    },
    
    deleteCamera(cameraId, camerasData) {
        try {
            const cameraIndex = camerasData.all.findIndex(cam => cam.id === cameraId);
            if (cameraIndex > -1) {
                const deletedCategory = camerasData.all[cameraIndex].category;
                camerasData.all.splice(cameraIndex, 1);
                
                // Update the category data
                if (camerasData[deletedCategory]) {
                    const categoryIndex = camerasData[deletedCategory].findIndex(cam => cam.id === cameraId);
                    if (categoryIndex > -1) {
                        camerasData[deletedCategory].splice(categoryIndex, 1);
                        if (camerasData[deletedCategory].length === 0) {
                            delete camerasData[deletedCategory];
                        }
                    }
                }
                return camerasData;
            }
            return camerasData;
        } catch (error) {
            console.error('Error deleting camera:', error);
            showToast('Failed to delete camera.', 'error');
            return camerasData;
        }
    },
    
    updateCamera(camera, camerasData) {
        try {
            const cameraIndex = camerasData.all.findIndex(cam => cam.id === camera.id);
            if (cameraIndex > -1) {
                const oldCategory = camerasData.all[cameraIndex].category;
                const newCategory = camera.category;
                
                // Update in 'all' array
                camerasData.all[cameraIndex] = {
                    ...camerasData.all[cameraIndex],
                    ...camera,
                };
                
                // Handle category change
                if (oldCategory !== newCategory) {
                    // Remove from old category
                    if (camerasData[oldCategory]) {
                        const oldCatIndex = camerasData[oldCategory].findIndex(cam => cam.id === camera.id);
                        if (oldCatIndex > -1) {
                            camerasData[oldCategory].splice(oldCatIndex, 1);
                            if (camerasData[oldCategory].length === 0) {
                                delete camerasData[oldCategory];
                            }
                        }
                    }
                    
                    // Add to new category
                    if (camerasData[newCategory]) {
                        camerasData[newCategory].push(camerasData.all[cameraIndex]);
                    } else {
                        camerasData[newCategory] = [camerasData.all[cameraIndex]];
                    }
                } else {
                    // Update in same category
                    if (camerasData[newCategory]) {
                        const catIndex = camerasData[newCategory].findIndex(cam => cam.id === camera.id);
                        if (catIndex > -1) {
                            camerasData[newCategory][catIndex] = {
                                ...camerasData.all[cameraIndex]
                            };
                        }
                    }
                }
                return camerasData;
            }
            return camerasData;
        } catch (error) {
            console.error('Error updating camera:', error);
            showToast('Failed to update camera.', 'error');
            return camerasData;
        }
    },
    
    updateCategory(oldCategory, newCategory, camerasData) {
        try {
            if (oldCategory === 'all' || newCategory === 'all') {
                showToast('Cannot rename to or from "All" category', 'error');
                return camerasData;
            }
            
            if (camerasData[oldCategory]) {
                // Create new category with same cameras
                camerasData[newCategory] = [...camerasData[oldCategory]];
                
                // Update category name in all cameras
                camerasData.all = camerasData.all.map(camera => {
                    if (camera.category === oldCategory) {
                        return { ...camera, category: newCategory };
                    }
                    return camera;
                });
                
                // Delete old category
                delete camerasData[oldCategory];
                return camerasData;
            }
            return camerasData;
        } catch (error) {
            console.error('Error updating category:', error);
            showToast('Failed to update category.', 'error');
            return camerasData;
        }
    }
};

let camerasData = dataService.loadCameras();

function updateConnectedCamsCount() {
    try {
        const allCams = camerasData.all || [];
        connectedCamsCount.textContent = `${allCams.length} Cams Connected`;
    } catch (error) {
        console.error('Error updating Connected Cams Count:', error);
        showToast('Error updating camera count', 'error');
    }
}

function updateTabs() {
    try {
        const tabsContainer = document.getElementById('cameraTabs');
        tabsContainer.innerHTML = '<button class="tab active" data-tab="all" aria-label="All Cameras">All</button>';
        const categories = new Set();

        for (const cam of camerasData.all) {
            categories.add(cam.category);
        }
        
        categories.forEach(category => {
            if (category === 'all') return; // Skip 'all' category as it's already added
            
            const categoryCount = camerasData[category]?.length || 0;
            tabsContainer.innerHTML += `<button class="tab" data-tab="${category}" aria-label="${category} Cameras">${category} (${categoryCount})</button>`;
        });
        
        // Add event listeners for tabs
        addTabEventListeners();
    } catch (error) {
        console.error('Error updating tabs:', error);
        showToast('Error updating camera categories', 'error');
    }
}

function addCamera(name, category, feedUrl, protocol) {
    try {
        // Determine camera type based on URL and protocol
        const isVideo = protocol !== 'http' || 
                        feedUrl.toLowerCase().endsWith('.mp4') || 
                        feedUrl.toLowerCase().endsWith('.m3u8') ||
                        feedUrl.toLowerCase().includes('stream');
        
        const newCamera = {
            id: cameraCounter++,
            name: name,
            category: category,
            feedUrl: feedUrl,
            recording: false,
            motion: false,
            muted: false,
            protocol: protocol,
            cameraOn: true,
            panX: 0,
            panY: 0,
            zoom: 1,
            type: isVideo ? 'video' : 'image',
            lastUpdated: new Date().toISOString()
        };

        camerasData = dataService.addCamera(newCamera, camerasData);
        const saved = dataService.saveCameras(camerasData);
        
        if (saved) {
            updateTabs();
            renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
            showToast(`Camera "${name}" added successfully`, 'success');
        }
    } catch (error) {
        console.error('Error adding camera:', error);
        showToast('Failed to add camera', 'error');
    }
}

function handleAddCamera(event) {
    event.preventDefault();
    try {
        const cameraName = document.getElementById('cameraName').value.trim();
        const cameraCategory = document.getElementById('cameraCategory').value.trim().toLowerCase();
        const cameraFeedUrl = document.getElementById('cameraFeedUrl').value.trim();
        const streamProtocol = document.getElementById('streamProtocol').value;

        if (!cameraName) {
            showToast('Please enter a camera name', 'error');
            return;
        }
        
        if (!cameraCategory) {
            showToast('Please enter a camera category', 'error');
            return;
        }
        
        if (!cameraFeedUrl) {
            showToast('Please enter a camera feed URL', 'error');
            return;
        }

        addCamera(cameraName, cameraCategory, cameraFeedUrl, streamProtocol);
        closeModal();
        // Clear the form
        addCameraForm.reset();
        document.getElementById('streamProtocol').value = 'auto';
    } catch (error) {
        console.error('Error handling add camera:', error);
        showToast('Error adding camera', 'error');
    }
}

function updateTimer() {
    try {
        timerSeconds++;
        const hours = Math.floor(timerSeconds / 3600);
        const minutes = Math.floor((timerSeconds % 3600) / 60);
        const seconds = timerSeconds % 60;

        const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        cameraTimerDisplay.textContent = formattedTime;
    } catch (error) {
        console.error('Error updating timer:', error);
    }
}

function startTimer() {
    try {
        stopTimer(); // Clear any existing timer
        timerSeconds = 0;
        updateTimer(); // Set initial value right away
        timerInterval = setInterval(updateTimer, 1000);
    } catch (error) {
        console.error('Error starting timer:', error);
    }
}

function stopTimer() {
    try {
        clearInterval(timerInterval);
        timerSeconds = 0;
    } catch (error) {
        console.error('Error stopping timer:', error);
    }
}

function renderCameraList(category = 'all') {
    try {
        const cameras = camerasData[category] || [];
        cameraListContainer.innerHTML = '';
        cameraListContainer.classList.toggle('empty-state', cameras.length === 0);

        cameras.forEach(camera => {
            const cameraItem = document.createElement('div');
            cameraItem.classList.add('camera-item');
            cameraItem.classList.add('loading-camera');
            cameraItem.dataset.cameraId = camera.id;

            if (camera.type === 'video' && camera.cameraOn) {
                cameraItem.innerHTML = `
                    <video autoplay muted loop playsinline style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);"></video>
                    <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}"></div>
                    <div class="camera-info">
                        <span class="camera-name">${camera.name}</span>
                        <div class="camera-actions">
                            <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}" aria-label="${camera.recording ? 'Stop Recording' : 'Start Recording'}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="${camera.recording ? 'red' : 'none'}" />
                                </svg>
                            </button>
                            <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-detected' : ''}" data-camera-id="${camera.id}" aria-label="${camera.motion ? 'Stop Motion Detection' : 'Start Motion Detection'}">
                                <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="24" cy="24" r="10" stroke="#00BFFF" stroke-width="3" fill="none" opacity="0.8"/>
                                    <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="#00FFFF" stroke-width="2" fill="none" />
                                    <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="#1E90FF" stroke-width="2" fill="none" opacity="0.6"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                
                const videoElement = cameraItem.querySelector('video');
                
                // Load video with error handling and retries
                loadVideoWithRetry(videoElement, camera, cameraItem);
                
            } else {
                cameraItem.innerHTML = `
                    <img src="${camera.feedUrl}" alt="${camera.name}" loading="lazy" onerror="this.onerror=null; this.src='/placeholder.svg'; this.parentElement.classList.remove('loading-camera');" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
                    <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}"></div>
                    <div class="camera-info">
                        <span class="camera-name">${camera.name}</span>
                        <div class="camera-actions">
                            <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}" aria-label="${camera.recording ? 'Stop Recording' : 'Start Recording'}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="${camera.recording ? 'red' : 'none'}" />
                                </svg>
                            </button>
                            <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-detected' : ''}" data-camera-id="${camera.id}" aria-label="${camera.motion ? 'Stop Motion Detection' : 'Start Motion Detection'}">
                                <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="24" cy="24" r="10" stroke="#00BFFF" stroke-width="3" fill="none" opacity="0.8"/>
                                    <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="#00FFFF" stroke-width="2" fill="none" />
                                    <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="#1E90FF" stroke-width="2" fill="none" opacity="0.6"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
            }
            
            const imgElement = cameraItem.querySelector('img');
            if (imgElement) {
                imgElement.addEventListener('load', () => {
                    cameraItem.classList.remove('loading-camera');
                });
            }

            cameraItem.addEventListener('click', () => {
                openCameraPage(camera);
            });

            cameraItem.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                currentEditCameraId = camera.id;
                openSettingsModal(camera);
            });

            cameraItem.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    let touchTimer;
                    touchTimer = setTimeout(() => {
                        currentEditCameraId = camera.id;
                        openSettingsModal(camera);
                    }, 500);

                    const clearTimer = () => {
                        clearTimeout(touchTimer);
                        cameraItem.removeEventListener('touchend', clearTimer);
                        cameraItem.removeEventListener('touchcancel', clearTimer);
                    };

                    cameraItem.addEventListener('touchend', clearTimer);
                    cameraItem.addEventListener('touchcancel', clearTimer);
                }
            });
            cameraListContainer.appendChild(cameraItem);
        });
        
        // Update the cam counts if needed
        updateConnectedCamsCount();
        
        // After rendering, add physics animations
        addAnimationToCameraButtons();
        addBounceOnHoverCameraItem();
    } catch (error) {
        console.error('Error rendering camera list:', error);
        showToast('Error displaying cameras', 'error');
    }
}

function loadVideoWithRetry(videoElement, camera, cameraItem, retryCount = 0) {
    const maxRetries = 3;
    
    try {
        // Determine which protocol to use
        const protocol = camera.protocol || 'auto';
        
        // Handle different streaming protocols
        if ((protocol === 'auto' && camera.feedUrl.toLowerCase().endsWith('.m3u8')) || protocol === 'hls') {
            // HLS Stream
            if (Hls.isSupported()) {
                const hls = new Hls({
                    maxBufferLength: 30,
                    maxMaxBufferLength: 60,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                });
                
                hls.loadSource(camera.feedUrl);
                hls.attachMedia(videoElement);
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    videoElement.play()
                        .then(() => {
                            cameraItem.classList.remove('loading-camera');
                        })
                        .catch(err => {
                            console.warn('Auto-play prevented:', err);
                            // Still remove loading state even if autoplay fails
                            cameraItem.classList.remove('loading-camera');
                        });
                });
                
                hls.on(Hls.Events.ERROR, function(event, data) {
                    if (data.fatal) {
                        console.error("HLS Error:", data);
                        
                        if (retryCount < maxRetries) {
                            console.log(`Retrying HLS stream (${retryCount + 1}/${maxRetries})...`);
                            setTimeout(() => {
                                hls.destroy();
                                loadVideoWithRetry(videoElement, camera, cameraItem, retryCount + 1);
                            }, 2000); // Wait 2 seconds before retry
                        } else {
                            console.error("Max retries reached, falling back to placeholder");
                            cameraItem.innerHTML = `<img src="/placeholder.svg" alt="${camera.name}" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
                            <div class="camera-overlay"></div>
                            <div class="camera-info">
                                <span class="camera-name">${camera.name} (Stream Error)</span>
                                <div class="camera-actions">
                                    <button class="camera-action-btn record" data-camera-id="${camera.id}">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="none" />
                                        </svg>
                                    </button>
                                </div>
                            </div>`;
                            cameraItem.classList.remove('loading-camera');
                        }
                    }
                });
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                videoElement.src = camera.feedUrl;
                videoElement.addEventListener('loadeddata', () => {
                    cameraItem.classList.remove('loading-camera');
                });
                
                videoElement.addEventListener('error', (e) => {
                    handleVideoError(e, camera, cameraItem, retryCount, maxRetries);
                });
            }
        } else if (protocol === 'rtsp') {
            // RTSP Stream - Using WebRTC as a transport for RTSP
            // In a real implementation, this would require a server-side component
            // For demo purposes, we'll simulate with a placeholder
            cameraItem.innerHTML = `
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #000;">
                    <div style="background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; color: white; text-align: center;">
                        <p>RTSP Stream</p>
                        <p style="font-size: 12px;">${camera.feedUrl}</p>
                    </div>
                </div>
                <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}"></div>
                <div class="camera-info">
                    <span class="camera-name">${camera.name}</span>
                    <div class="camera-actions">
                        <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="${camera.recording ? 'red' : 'none'}" />
                            </svg>
                        </button>
                        <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-detected' : ''}" data-camera-id="${camera.id}">
                            <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="24" cy="24" r="10" stroke="#00BFFF" stroke-width="3" fill="none" opacity="0.8"/>
                                <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="#00FFFF" stroke-width="2" fill="none" />
                                <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="#1E90FF" stroke-width="2" fill="none" opacity="0.6"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
            cameraItem.classList.remove('loading-camera');
        } else if (protocol === 'webrtc') {
            // WebRTC Stream
            // In a real implementation, this would require signaling
            // For demo purposes, we'll simulate with a placeholder
            cameraItem.innerHTML = `
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #000;">
                    <div style="background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; color: white; text-align: center;">
                        <p>WebRTC Stream</p>
                        <p style="font-size: 12px;">${camera.feedUrl}</p>
                    </div>
                </div>
                <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}"></div>
                <div class="camera-info">
                    <span class="camera-name">${camera.name}</span>
                    <div class="camera-actions">
                        <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="${camera.recording ? 'red' : 'none'}" />
                            </svg>
                        </button>
                        <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-detected' : ''}" data-camera-id="${camera.id}">
                            <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="24" cy="24" r="10" stroke="#00BFFF" stroke-width="3" fill="none" opacity="0.8"/>
                                <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="#00FFFF" stroke-width="2" fill="none" />
                                <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="#1E90FF" stroke-width="2" fill="none" opacity="0.6"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
            cameraItem.classList.remove('loading-camera');
        } else if (protocol === 'mjpeg') {
            // MJPEG Stream
            // Create an img element for MJPEG stream
            cameraItem.innerHTML = `
                <img src="${camera.feedUrl}" alt="${camera.name}" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
                <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}"></div>
                <div class="camera-info">
                    <span class="camera-name">${camera.name}</span>
                    <div class="camera-actions">
                        <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="${camera.recording ? 'red' : 'none'}" />
                            </svg>
                        </button>
                        <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-detected' : ''}" data-camera-id="${camera.id}">
                            <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="24" cy="24" r="10" stroke="#00BFFF" stroke-width="3" fill="none" opacity="0.8"/>
                                <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="#00FFFF" stroke-width="2" fill="none" />
                                <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="#1E90FF" stroke-width="2" fill="none" opacity="0.6"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
            
            const imgElement = cameraItem.querySelector('img');
            imgElement.addEventListener('load', () => {
                cameraItem.classList.remove('loading-camera');
            });
            
            imgElement.addEventListener('error', (e) => {
                console.error("MJPEG error:", e);
                
                if (retryCount < maxRetries) {
                    console.log(`Retrying MJPEG stream (${retryCount + 1}/${maxRetries})...`);
                    setTimeout(() => {
                        loadVideoWithRetry(videoElement, camera, cameraItem, retryCount + 1);
                    }, 2000);
                } else {
                    cameraItem.innerHTML = `<img src="/placeholder.svg" alt="${camera.name}" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
                    <div class="camera-overlay"></div>
                    <div class="camera-info">
                        <span class="camera-name">${camera.name} (Stream Error)</span>
                        <div class="camera-actions">
                            <button class="camera-action-btn record" data-camera-id="${camera.id}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="none" />
                                </svg>
                            </button>
                        </div>
                    </div>`;
                    cameraItem.classList.remove('loading-camera');
                }
            });
        } else {
            // Regular HTTP video or auto-detect
            videoElement.src = camera.feedUrl;
            videoElement.addEventListener('loadeddata', () => {
                cameraItem.classList.remove('loading-camera');
            });
            
            videoElement.addEventListener('error', (e) => {
                handleVideoError(e, camera, cameraItem, retryCount, maxRetries);
            });
        }
    } catch (error) {
        console.error('Error loading video:', error);
        cameraItem.innerHTML = `<img src="/placeholder.svg" alt="${camera.name}" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
        <div class="camera-info">
            <span class="camera-name">${camera.name} (Error)</span>
        </div>`;
        cameraItem.classList.remove('loading-camera');
    }
}

function handleVideoError(error, camera, cameraItem, retryCount, maxRetries) {
    console.error("Video error:", error);
    
    if (retryCount < maxRetries) {
        console.log(`Retrying video load (${retryCount + 1}/${maxRetries})...`);
        setTimeout(() => {
            loadVideoWithRetry(null, camera, cameraItem, retryCount + 1);
        }, 2000);
    } else {
        cameraItem.innerHTML = `<img src="/placeholder.svg" alt="${camera.name}" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
        <div class="camera-overlay"></div>
        <div class="camera-info">
            <span class="camera-name">${camera.name} (Stream Error)</span>
            <div class="camera-actions">
                <button class="camera-action-btn record" data-camera-id="${camera.id}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="none" />
                    </svg>
                </button>
            </div>
        </div>`;
        cameraItem.classList.remove('loading-camera');
    }
}

function addBounceOnHoverCameraItem() {
    try {
        const cameraItems = document.querySelectorAll('.camera-item');
        cameraItems.forEach(item => {
            item.addEventListener('mouseenter', () => {
                gsap.to(item, {
                    scale: 1.02,
                    duration: 0.3,
                    ease: 'back.out(1.7)'
                });
            });
            item.addEventListener('mouseleave', () => {
                gsap.to(item, {
                    scale: 1,
                    duration: 0.3,
                    ease: 'back.out(1.7)'
                });
            });
        });
    } catch (error) {
        console.error('Error adding bounce effect:', error);
    }
}

function openCameraPage(cameraData) {
    try {
        currentCameraData = cameraData; // Store the clicked camera's data
        const cameraFeedContainer = cameraPage.querySelector('.camera-feed');
        cameraFeedContainer.innerHTML = '';
        cameraFeedContainer.classList.add('loading');
        
        // Reset protocol selector to match camera's protocol or auto
        protocolSelector.value = cameraData.protocol || 'auto';
        currentStreamProtocol = protocolSelector.value;
        
        // Hide error overlay initially
        streamErrorOverlay.classList.remove('active');
        streamRetryCount = 0;

        setTimeout(() => {
            cameraFeedContainer.classList.remove('loading');

            if (cameraData.cameraOn) {
                cameraFeedContainer.classList.add('live');
                cameraFeedContainer.classList.remove('live-off');
                displayLiveCameraFeed(cameraData, cameraFeedContainer);
            } else {
                cameraFeedContainer.classList.remove('live');
                cameraFeedContainer.classList.add('live-off');
                cameraFeedContainer.innerHTML = `<img src="${cameraData.feedUrl}" alt="Camera Feed" style="display:block; transform: scale(${cameraData.zoom}) translateX(${cameraData.panX}px) translateY(${cameraData.panY}px);" loading="lazy" onerror="this.onerror=null; this.src='/placeholder.svg'">`;
            }
        }, 500);

        gsap.to(homePage, {
            x: '-100%',
            duration: 0.5,
            ease: 'power2.inOut'
        });
        gsap.fromTo(cameraPage, {
            x: '100%'
        }, {
            x: '0%',
            duration: 0.5,
            ease: 'power2.inOut'
        });
        startTimer(); // Start the timer when opening the camera page
    } catch (error) {
        console.error('Error opening camera page:', error);
        showToast('Error opening camera view', 'error');
    }
}

function displayLiveCameraFeed(cameraData, cameraFeedContainer) {
    try {
        cameraFeedContainer.innerHTML = ''; // Clear previous content
        
        // Use the selected protocol or the camera's default
        const protocol = currentStreamProtocol === 'auto' ? (cameraData.protocol || 'auto') : currentStreamProtocol;
        
        if (protocol === 'rtsp') {
            // RTSP Stream - Using WebRTC as a transport for RTSP
            cameraFeedContainer.innerHTML = `
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #000;">
                    <div style="background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; color: white; text-align: center;">
                        <p>RTSP Stream</p>
                        <p style="font-size: 12px;">${cameraData.feedUrl}</p>
                    </div>
                </div>
            `;
        } else if (protocol === 'webrtc') {
            // WebRTC Stream
            cameraFeedContainer.innerHTML = `
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #000;">
                    <div style="background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; color: white; text-align: center;">
                        <p>WebRTC Stream</p>
                        <p style="font-size: 12px;">${cameraData.feedUrl}</p>
                    </div>
                </div>
            `;
        } else if (protocol === 'mjpeg') {
            // MJPEG Stream
            const img = document.createElement('img');
            img.src = cameraData.feedUrl;
            img.alt = "Camera Feed";
            img.style.transform = `scale(${cameraData.zoom}) translateX(${cameraData.panX}px) translateY(${cameraData.panY}px)`;
            img.onerror = function() {
                this.onerror = null;
                this.src = '/placeholder.svg';
                streamErrorMessage.textContent = "Unable to load MJPEG stream. Please check the URL and try again.";
                streamErrorOverlay.classList.add('active');
            };
            cameraFeedContainer.appendChild(img);
        } else if ((protocol === 'auto' && cameraData.feedUrl.toLowerCase().endsWith('.m3u8')) || protocol === 'hls') {
            // HLS Stream
            const videoElement = document.createElement('video');
            videoElement.autoplay = true;
            videoElement.controls = false;
            videoElement.muted = true;
            videoElement.playsInline = true;
            videoElement.style.transform = `scale(${cameraData.zoom}) translateX(${cameraData.panX}px) translateY(${cameraData.panY}px)`;
            cameraFeedContainer.appendChild(videoElement);
            
            if (Hls.isSupported()) {
                const hls = new Hls({
                    maxBufferLength: 30,
                    maxMaxBufferLength: 60,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                });
                
                hls.loadSource(cameraData.feedUrl);
                hls.attachMedia(videoElement);
                
                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    videoElement.play()
                        .catch(e => console.warn('Autoplay prevented:', e));
                });
                
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error("HLS Error:", data);
                    
                    if (data.fatal) {
                        if (streamRetryCount < maxStreamRetries) {
                            streamRetryCount++;
                            showToast(`Stream error, retrying (${streamRetryCount}/${maxStreamRetries})...`, 'warning');
                            
                            setTimeout(() => {
                                hls.destroy();
                                displayLiveCameraFeed(cameraData, cameraFeedContainer);
                            }, 2000);
                        } else {
                            // Show error overlay with retry button
                            streamErrorMessage.textContent = "Unable to connect to HLS stream. Please check your connection and the stream URL.";
                            streamErrorOverlay.classList.add('active');
                        }
                    }
                });
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                videoElement.src = cameraData.feedUrl;
                
                videoElement.addEventListener('loadedmetadata', function() {
                    videoElement.play()
                        .catch(e => console.warn('Autoplay prevented:', e));
                });
                
                videoElement.addEventListener('error', function(e) {
                    console.error("Video error:", e);
                    
                    if (streamRetryCount < maxStreamRetries) {
                        streamRetryCount++;
                        showToast(`Stream error, retrying (${streamRetryCount}/${maxStreamRetries})...`, 'warning');
                        
                        setTimeout(() => {
                            displayLiveCameraFeed(cameraData, cameraFeedContainer);
                        }, 2000);
                    } else {
                        streamErrorMessage.textContent = "Unable to play HLS stream. The format may be unsupported or the stream is unavailable.";
                        streamErrorOverlay.classList.add('active');
                    }
                });
            } else {
                streamErrorMessage.textContent = "Your browser doesn't support HLS streaming. Please try a different protocol.";
                streamErrorOverlay.classList.add('active');
            }
        } else {
            // Regular HTTP video or auto-detect for non-HLS
            const videoElement = document.createElement('video');
            videoElement.autoplay = true;
            videoElement.controls = false;
            videoElement.muted = true;
            videoElement.playsInline = true;
            videoElement.style.transform = `scale(${cameraData.zoom}) translateX(${cameraData.panX}px) translateY(${cameraData.panY}px)`;
            videoElement.src = cameraData.feedUrl;
            cameraFeedContainer.appendChild(videoElement);
            
            videoElement.addEventListener('error', function(e) {
                console.error("Video error:", e);
                
                if (streamRetryCount < maxStreamRetries) {
                    streamRetryCount++;
                    showToast(`Stream error, retrying (${streamRetryCount}/${maxStreamRetries})...`, 'warning');
                    
                    setTimeout(() => {
                        displayLiveCameraFeed(cameraData, cameraFeedContainer);
                    }, 2000);
                } else {
                    streamErrorMessage.textContent = "Your browser doesn't support this video format or the stream is unavailable.";
                    streamErrorOverlay.classList.add('active');
                }
            });
        }
    } catch (error) {
        console.error('Error displaying live camera feed:', error);
        cameraFeedContainer.innerHTML = `<div style="color:red; text-align:center; padding:20px;">Error loading camera feed</div>`;
    }
}

function closeCameraPage() {
    try {
        stopTimer(); // Stop the timer when closing camera page
        const cameraFeedContainer = cameraPage.querySelector('.camera-feed');
        cameraFeedContainer.innerHTML = '';
        cameraFeedContainer.classList.remove('live', 'live-off', 'loading');
        streamErrorOverlay.classList.remove('active');
        
        gsap.to(cameraPage, {
            x: '100%',
            duration: 0.5,
            ease: 'power2.inOut'
        });
        gsap.fromTo(homePage, {
            x: '-100%'
        }, {
            x: '0%',
            duration: 0.5,
            ease: 'power2.inOut'
        });
    } catch (error) {
        console.error('Error closing camera page:', error);
    }
}

function performCameraAction(action) {
    try {
        if (!currentCameraData) {
            console.error('No camera selected');
            return;
        }
        
        const camera = camerasData.all.find(cam => cam.id === currentCameraData.id);
        if (!camera) {
            console.error('Camera not found in data');
            return;
        }
        
        switch (action) {
            case 'mute':
                toggleMute(camera.id);
                break;
            case 'record':
                toggleRecording(camera.id);
                break;
            case 'zoom-in':
                adjustZoom(camera, 0.1);
                break;
            case 'zoom-out':
                adjustZoom(camera, -0.1);
                break;
            case 'pan-left':
                adjustPan(camera, -10, 0);
                break;
            case 'pan-right':
                adjustPan(camera, 10, 0);
                break;
            case 'camera-btn':
                toggleCamera(camera.id);
                break;
            default:
                console.warn('Unknown camera action:', action);
        }
        
        // Save changes
        dataService.saveCameras(camerasData);
    } catch (error) {
        console.error('Error performing camera action:', error);
        showToast('Error controlling camera', 'error');
    }
}

function toggleMute(cameraId) {
    try {
        const camera = camerasData.all.find(cam => cam.id === cameraId);
        if (camera) {
            camera.muted = !camera.muted;
            
            // Update UI to show mute state
            const muteLine = document.getElementById('muteLine');
            muteLine.style.display = camera.muted ? 'block' : 'none';
            
            // If in camera view, mute/unmute the video
            const videoElement = document.querySelector('.camera-feed video');
            if (videoElement) {
                videoElement.muted = camera.muted;
            }
            
            showToast(`Camera ${camera.muted ? 'muted' : 'unmuted'}`, 'info');
        }
    } catch (error) {
        console.error('Error toggling mute:', error);
    }
}

function toggleRecording(cameraId) {
    try {
        const camera = camerasData.all.find(cam => cam.id === cameraId);
        if (camera) {
            camera.recording = !camera.recording;
            
            // Find and update all record buttons for this camera
            const recordButtons = document.querySelectorAll(`.camera-action-btn.record[data-camera-id="${cameraId}"]`);
            recordButtons.forEach(button => {
                button.classList.toggle('recording', camera.recording);
                const svgCircle = button.querySelector('svg circle');
                if (svgCircle) {
                    svgCircle.setAttribute('fill', camera.recording ? 'red' : 'none');
                }
            });
            
            dataService.saveCameras(camerasData);
            showToast(`Recording ${camera.recording ? 'started' : 'stopped'}`, camera.recording ? 'success' : 'info');
            renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
        }
    } catch (error) {
        console.error('Error toggling recording:', error);
    }
}

function adjustZoom(camera, amount) {
    try {
        camera.zoom += amount;
        camera.zoom = Math.max(0.5, Math.min(2, camera.zoom));
        
        // Update all instances of this camera's display
        updateCameraTransform(camera);
        
        dataService.saveCameras(camerasData);
    } catch (error) {
        console.error('Error adjusting zoom:', error);
    }
}

function adjustPan(camera, panX, panY) {
    try {
        camera.panX += panX;
        camera.panY += panY;
        
        // Limit pan range
        camera.panX = Math.max(-100, Math.min(100, camera.panX));
        camera.panY = Math.max(-100, Math.min(100, camera.panY));
        
        // Update all instances of this camera's display
        updateCameraTransform(camera);
        
        dataService.saveCameras(camerasData);
    } catch (error) {
        console.error('Error adjusting pan:', error);
    }
}

function updateCameraTransform(camera) {
    try {
        // Update in camera list
        const listItems = document.querySelectorAll(`.camera-item[data-camera-id="${camera.id}"]`);
        listItems.forEach(item => {
            const mediaElement = item.querySelector('img, video');
            if (mediaElement) {
                mediaElement.style.transform = `scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px)`;
            }
        });
        
        // Update in camera view if this is the current camera
        if (currentCameraData && currentCameraData.id === camera.id) {
            const cameraFeed = document.querySelector('.camera-feed img, .camera-feed video');
            if (cameraFeed) {
                cameraFeed.style.transform = `scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px)`;
            }
        }
    } catch (error) {
        console.error('Error updating camera transform:', error);
    }
}

function toggleMotionDetection(cameraId) {
    try {
        const camera = camerasData.all.find(cam => cam.id === cameraId);
        if (camera) {
            camera.motion = !camera.motion;
            
            // Update all motion detection buttons for this camera
            const motionButtons = document.querySelectorAll(`.camera-action-btn.motion-detection[data-camera-id="${cameraId}"]`);
            motionButtons.forEach(button => {
                button.classList.toggle('motion-detected', camera.motion);
            });
            
            // Update overlays
            const overlays = document.querySelectorAll(`.camera-item[data-camera-id="${cameraId}"] .camera-overlay`);
            overlays.forEach(overlay => {
                overlay.classList.toggle('motion-detected-overlay', camera.motion);
            });
            
            dataService.saveCameras(camerasData);
            showToast(`Motion detection ${camera.motion ? 'enabled' : 'disabled'}`, 'info');
            renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
        }
    } catch (error) {
        console.error('Error toggling motion detection:', error);
    }
}

function toggleCamera(cameraId) {
    try {
        const camera = camerasData.all.find(cam => cam.id === cameraId);
        if (camera) {
            camera.cameraOn = !camera.cameraOn;
            
            // Update camera feed display
            const cameraFeedContainer = document.querySelector('.camera-feed');
            if (cameraFeedContainer && currentCameraData && currentCameraData.id === cameraId) {
                cameraFeedContainer.classList.remove('live', 'live-off', 'loading');
                
                if (camera.cameraOn) {
                    cameraFeedContainer.classList.add('live');
                    displayLiveCameraFeed(camera, cameraFeedContainer);
                } else {
                    cameraFeedContainer.classList.add('live-off');
                    cameraFeedContainer.innerHTML = `<img src="${camera.feedUrl}" alt="Camera Feed" style="display:block; transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);" loading="lazy" onerror="this.onerror=null; this.src='/placeholder.svg'">`;
                }
            }
            
            // Update overlays in camera list
            const overlays = document.querySelectorAll(`.camera-item[data-camera-id="${cameraId}"] .camera-overlay`);
            overlays.forEach(overlay => {
                overlay.classList.toggle('camera-off', !camera.cameraOn);
            });
            
            dataService.saveCameras(camerasData);
            showToast(`Camera ${camera.cameraOn ? 'turned on' : 'turned off'}`, 'info');
            renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
        }
    } catch (error) {
        console.error('Error toggling camera:', error);
    }
}

function openModal() {
    try {
        addCameraModal.classList.add('active');
    } catch (error) {
        console.error('Error opening modal:', error);
    }
}

function closeModal() {
    try {
        addCameraModal.classList.remove('active');
    } catch (error) {
        console.error('Error closing modal:', error);
    }
}

function openConfirmationModal() {
    try {
        confirmationModal.classList.add('active');
    } catch (error) {
        console.error('Error opening confirmation modal:', error);
    }
}

function closeConfirmationModal() {
    try {
        confirmationModal.classList.remove('active');
    } catch (error) {
        console.error('Error closing confirmation modal:', error);
    }
}

function openSettingsModal(camera) {
    try {
        settingsModal.classList.add('active');
        document.getElementById('editCameraName').value = camera.name;
        document.getElementById('editCameraCategory').value = camera.category;
        document.getElementById('editCameraFeedUrl').value = camera.feedUrl;
        document.getElementById('editStreamProtocol').value = camera.protocol || 'auto';
        document.getElementById('editCameraOn').checked = camera.cameraOn;
    } catch (error) {
        console.error('Error opening settings modal:', error);
    }
}

function closeSettingsModal() {
    try {
        settingsModal.classList.remove('active');
    } catch (error) {
        console.error('Error closing settings modal:', error);
    }
}

function handleSettingsSubmit(event) {
    event.preventDefault();
    try {
        const editedName = document.getElementById('editCameraName').value.trim();
        const editedCategory = document.getElementById('editCameraCategory').value.trim();
        const editedFeedUrl = document.getElementById('editCameraFeedUrl').value.trim();
        const editedProtocol = document.getElementById('editStreamProtocol').value;
        const editedCameraOn = document.getElementById('editCameraOn').checked;
        
        if (!editedName) {
            showToast('Camera name cannot be empty', 'error');
            return;
        }
        
        if (!editedCategory) {
            showToast('Camera category cannot be empty', 'error');
            return;
        }
        
        if (!editedFeedUrl) {
            showToast('Camera feed URL cannot be empty', 'error');
            return;
        }
        
        if (currentEditCameraId) {
            const camera = camerasData.all.find(cam => cam.id === currentEditCameraId);
            if (camera) {
                // Determine if this is a video based on protocol and URL
                const isVideo = editedProtocol !== 'http' || 
                               editedFeedUrl.toLowerCase().endsWith('.mp4') || 
                               editedFeedUrl.toLowerCase().endsWith('.m3u8') ||
                               editedFeedUrl.toLowerCase().includes('stream');
                
                camerasData = dataService.updateCamera({
                    ...camera,
                    name: editedName,
                    category: editedCategory,
                    feedUrl: editedFeedUrl,
                    protocol: editedProtocol,
                    cameraOn: editedCameraOn,
                    type: isVideo ? 'video' : 'image',
                    lastUpdated: new Date().toISOString()
                }, camerasData);
                
                const saved = dataService.saveCameras(camerasData);
                if (saved) {
                    closeSettingsModal();
                    showToast('Camera settings updated', 'success');
                    
                    // Update tabs if category changed
                    if (camera.category !== editedCategory) {
                        updateTabs();
                    }
                    
                    // Refresh the current view
                    renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
                    
                    // If this is the current camera in view, update it
                    if (currentCameraData && currentCameraData.id === currentEditCameraId) {
                        currentCameraData = camerasData.all.find(cam => cam.id === currentEditCameraId);
                        const cameraFeedContainer = document.querySelector('.camera-feed');
                        if (cameraFeedContainer) {
                            displayLiveCameraFeed(currentCameraData, cameraFeedContainer);
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.error('Error handling settings submit:', error);
        showToast('Error updating camera settings', 'error');
    }
}

function deleteCamera() {
    try {
        if (currentEditCameraId) {
            camerasData = dataService.deleteCamera(currentEditCameraId, camerasData);
            const saved = dataService.saveCameras(camerasData);
            
            if (saved) {
                closeConfirmationModal();
                closeSettingsModal();
                showToast('Camera deleted', 'success');
                
                // If the deleted camera was the current one in view, go back to home
                if (currentCameraData && currentCameraData.id === currentEditCameraId) {
                    closeCameraPage();
                }
                
                updateTabs();
                renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
            }
        }
    } catch (error) {
        console.error('Error deleting camera:', error);
        showToast('Error deleting camera', 'error');
    }
}

function showToast(message, type = 'info') {
    try {
        toast.textContent = message;
        toast.className = 'toast'; // Reset classes
        toast.classList.add('active', type);
        
        // Clear any existing timeout
        if (toast.timeoutId) {
            clearTimeout(toast.timeoutId);
        }
        
        // Hide after 3 seconds
        toast.timeoutId = setTimeout(() => {
            toast.classList.remove('active');
            toast.classList.add('hidden');
        }, 3000);
    } catch (error) {
        console.error('Error showing toast:', error);
    }
}

function addTabEventListeners() {
    try {
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            let touchTimer;
            
                        // Click event for changing tabs
                        tab.addEventListener('click', (event) => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                event.target.classList.add('active');
                renderCameraList(event.target.dataset.tab);
            });
            
            // Long press for category options (mobile)
            tab.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    touchTimer = setTimeout(() => {
                        const category = event.target.dataset.tab;
                        if (category !== 'all') { // Don't allow editing "All" category
                            openCategoryModal(category);
                        } else {
                            showToast('Cannot edit the "All" category', 'info');
                        }
                    }, 500);

                    const clearTimer = () => {
                        clearTimeout(touchTimer);
                        tab.removeEventListener('touchend', clearTimer);
                        tab.removeEventListener('touchcancel', clearTimer);
                    };

                    tab.addEventListener('touchend', clearTimer);
                tab.addEventListener('touchcancel', clearTimer);
            }});
            
            // Right-click for category options (desktop)
            tab.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                const category = event.target.dataset.tab;
                if (category !== 'all') { // Don't allow editing "All" category
                    openCategoryModal(category);
                } else {
                    showToast('Cannot edit the "All" category', 'info');
                }
            });
        });
    } catch (error) {
        console.error('Error adding tab event listeners:', error);
    }
}

function updateCategory(oldCategory, newCategory) {
    try {
        if (oldCategory === 'all' || newCategory === 'all') {
            showToast('Cannot rename to or from "All" category', 'error');
            return;
        }
        
        camerasData = dataService.updateCategory(oldCategory, newCategory, camerasData);
        const saved = dataService.saveCameras(camerasData);
        
        if (saved) {
            updateTabs();
            renderCameraList(document.querySelector('.tab.active')?.dataset.tab || 'all');
            showToast(`Category renamed to "${newCategory}"`, 'success');
        }
    } catch (error) {
        console.error('Error updating category:', error);
        showToast('Error renaming category', 'error');
    }
}

function deleteCategory(category) {
    try {
        if (category === 'all') {
            showToast('Cannot delete the "All" category', 'error');
            return;
        }
        
        camerasData = dataService.deleteCategory(category, camerasData);
        const saved = dataService.saveCameras(camerasData);
        
        if (saved) {
            updateTabs();
            // Switch to "All" tab after deleting a category
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector('.tab[data-tab="all"]').classList.add('active');
            renderCameraList('all');
            showToast(`Category "${category}" deleted`, 'success');
        }
    } catch (error) {
        console.error('Error deleting category:', error);
        showToast('Error deleting category', 'error');
    }
}

function openCategoryModal(category) {
    try {
        categoryModal.classList.add('active');
        currentCategoryEdit = category;
        document.getElementById('categoryModalTitle').textContent = `Options for "${category}"`;
        document.getElementById('newCategoryName').value = category;
    } catch (error) {
        console.error('Error opening category modal:', error);
    }
}

function closeCategoryModal() {
    try {
        categoryModal.classList.remove('active');
        currentCategoryEdit = null;
    } catch (error) {
        console.error('Error closing category modal:', error);
    }
}

function handleCategoryFormSubmit(event) {
    event.preventDefault();
    try {
        const newCategoryName = document.getElementById('newCategoryName').value.trim().toLowerCase();
        
        if (!newCategoryName) {
            showToast('Category name cannot be empty', 'error');
            return;
        }
        
        if (newCategoryName === 'all') {
            showToast('Cannot use "all" as a category name', 'error');
            return;
        }
        
        if (currentCategoryEdit && newCategoryName !== currentCategoryEdit) {
            updateCategory(currentCategoryEdit, newCategoryName);
            closeCategoryModal();
        } else if (newCategoryName === currentCategoryEdit) {
            showToast('No changes made to category name', 'info');
            closeCategoryModal();
        }
    } catch (error) {
        console.error('Error handling category form submit:', error);
        showToast('Error updating category', 'error');
    }
}

function handleDeleteCategory() {
    try {
        if (currentCategoryEdit) {
            deleteCategory(currentCategoryEdit);
            closeCategoryModal();
        }
    } catch (error) {
        console.error('Error handling delete category:', error);
        showToast('Error deleting category', 'error');
    }
}

function handleKeyboardNavigation(e) {
    try {
        if (e.key === 'Escape') {
            // Close any open modals
            if (addCameraModal.classList.contains('active')) {
                closeModal();
            } else if (settingsModal.classList.contains('active')) {
                closeSettingsModal();
            } else if (confirmationModal.classList.contains('active')) {
                closeConfirmationModal();
            } else if (categoryModal.classList.contains('active')) {
                closeCategoryModal();
            } else if (cameraPage.style.transform !== 'translateX(100%)') {
                // If no modals are open but we're on the camera page, go back
                closeCameraPage();
            }
        } else if (e.key === 'ArrowLeft') {
            if (cameraPage.style.transform !== 'translateX(100%)') {
                closeCameraPage();
            }
        } else if (e.key === 'ArrowRight') {
            if (landingPage.style.transform === 'translateX(0%)') {
                gsap.to(landingPage, {
                    x: '-100%',
                    duration: 0.5,
                    ease: 'power2.inOut'
                });
                gsap.fromTo(homePage, {
                    x: '100%'
                }, {
                    x: '0%',
                    duration: 0.5,
                    ease: 'power2.inOut'
                });
            }
        }
    } catch (error) {
        console.error('Error handling keyboard navigation:', error);
    }
}

// Retry stream connection
retryStreamBtn.addEventListener('click', () => {
    try {
        streamErrorOverlay.classList.remove('active');
        streamRetryCount = 0;
        
        if (currentCameraData) {
            const cameraFeedContainer = document.querySelector('.camera-feed');
            if (cameraFeedContainer) {
                cameraFeedContainer.innerHTML = '';
                cameraFeedContainer.classList.add('loading');
                
                setTimeout(() => {
                    cameraFeedContainer.classList.remove('loading');
                    displayLiveCameraFeed(currentCameraData, cameraFeedContainer);
                }, 500);
            }
        }
    } catch (error) {
        console.error('Error retrying stream:', error);
        showToast('Error reconnecting to stream', 'error');
    }
});

// Initial Rendering
try {
    updateTabs();
    renderCameraList('all');
    updateNetworkStatus();
} catch (error) {
    console.error('Error during initial render:', error);
    showToast('Error initializing application', 'error');
}

// Event Listeners
getStartedBtn.addEventListener('click', () => {
    try {
        gsap.to(landingPage, {
            x: '-100%',
            duration: 0.5,
            ease: 'power2.inOut'
        });
        gsap.fromTo(homePage, {
            x: '100%'
        }, {
            x: '0%',
            duration: 0.5,
            ease: 'power2.inOut'
        });
    } catch (error) {
        console.error('Error on get started button:', error);
    }
});

backBtn.addEventListener('click', closeCameraPage);

cameraListContainer.addEventListener('click', (event) => {
    try {
        const recordButton = event.target.closest('.camera-action-btn.record');
        const motionButton = event.target.closest('.camera-action-btn.motion-detection');
        
        if (recordButton) {
            event.stopPropagation(); // Prevent opening camera view
            const cameraId = parseInt(recordButton.dataset.cameraId);
            toggleRecording(cameraId);
        } else if (motionButton) {
            event.stopPropagation(); // Prevent opening camera view
            const cameraId = parseInt(motionButton.dataset.cameraId);
            toggleMotionDetection(cameraId);
        }
    } catch (error) {
        console.error('Error handling camera list click:', error);
    }
});

function addAnimationToCameraButtons() {
    try {
        const buttons = document.querySelectorAll('.camera-action-btn');
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                gsap.to(button, {
                    scale: 1.1,
                    duration: 0.3,
                    ease: 'back.out(1.7)'
                });
            });
            button.addEventListener('mouseleave', () => {
                gsap.to(button, {
                    scale: 1,
                    duration: 0.3,
                    ease: 'back.out(1.7)'
                });
            });
            button.addEventListener('mousedown', () => {
                gsap.to(button, {
                    scale: 0.95,
                    duration: 0.1
                });
            });
            button.addEventListener('mouseup', () => {
                gsap.to(button, {
                    scale: 1,
                    duration: 0.1
                });
            });
        });
    } catch (error) {
        console.error('Error adding animation to camera buttons:', error);
    }
}

// Add physics-based animations for badge
const floatingElements = document.querySelectorAll('.animate-float');
floatingElements.forEach(element => {
    try {
        gsap.to(element, {
            y: -10,
            duration: 1.5,
            repeat: -1,
            yoyo: true,
            ease: 'power1.inOut'
        });
    } catch (error) {
        console.error('Error animating floating elements:', error);
    }
});

// Camera Control Buttons
cameraControls.addEventListener('click', (event) => {
    try {
        const controlButton = event.target.closest('button[data-action], .d-pad-button[data-action]');
        if (controlButton) {
            const action = controlButton.dataset.action;
            performCameraAction(action);
        }
    } catch (error) {
        console.error('Error handling camera controls click:', error);
    }
});

// Prevent default touch behavior on camera controls
cameraControls.addEventListener('touchstart', (e) => {
    e.preventDefault();
}, { passive: false });

// Modal and form event listeners
addCamBtn.addEventListener('click', openModal);
closeModalBtn.addEventListener('click', closeModal);
addCameraForm.addEventListener('submit', handleAddCamera);
settingsForm.addEventListener('submit', handleSettingsSubmit);
closeSettingsModalBtn.addEventListener('click', closeSettingsModal);
deleteCameraBtn.addEventListener('click', () => {
    closeSettingsModal();
    openConfirmationModal();
});
confirmDeleteBtn.addEventListener('click', deleteCamera);
cancelDeleteBtn.addEventListener('click', closeConfirmationModal);
categoryForm.addEventListener('submit', handleCategoryFormSubmit);
deleteCategoryBtn.addEventListener('click', handleDeleteCategory);
closeCategoryModalBtn.addEventListener('click', closeCategoryModal);
document.addEventListener('keydown', handleKeyboardNavigation);

// Initialize animations and event listeners
addAnimationToCameraButtons();
addTabEventListeners();

// Periodically check network status
setInterval(updateNetworkStatus, 30000); // Check every 30 seconds

// Auto-save camera data periodically
setInterval(() => {
    try {
        dataService.saveCameras(camerasData);
    } catch (error) {
        console.error('Error auto-saving camera data:', error);
    }
}, 60000); // Save every minute

// Add support for WebRTC streaming
function setupWebRTCStream(videoElement, streamUrl) {
    try {
        // Create peer connection
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        });
        
        // Set up event handlers
        pc.onicecandidate = event => {
            if (event.candidate) {
                // In a real app, you would send this to the signaling server
                console.log("ICE candidate", event.candidate);
            }
        };
        
        pc.ontrack = event => {
            if (videoElement) {
                videoElement.srcObject = event.streams[0];
                videoElement.play()
                    .catch(e => console.warn('Autoplay prevented:', e));
            }
        };
        
        // Create data channel for control messages
        const dataChannel = pc.createDataChannel('controls');
        dataChannel.onopen = () => console.log('WebRTC data channel open');
        dataChannel.onclose = () => console.log('WebRTC data channel closed');
        
        // Fetch offer from server (in a real app)
        fetch(streamUrl)
            .then(response => response.json())
            .then(data => {
                pc.setRemoteDescription(new RTCSessionDescription(data.offer))
                    .then(() => pc.createAnswer())
                    .then(answer => pc.setLocalDescription(answer))
                    .then(() => {
                        // In a real app, you would send this to the signaling server
                        console.log("Answer created", pc.localDescription);
                    })
                    .catch(err => {
                        console.error("Error setting up WebRTC:", err);
                        throw err;
                    });
            })
            .catch(err => {
                console.error("Error fetching WebRTC offer:", err);
                throw err;
            });
            
        return pc; // Return the connection for cleanup
    } catch (error) {
        console.error('Error setting up WebRTC stream:', error);
        throw error;
    }
}

// Add support for RTSP streaming via WebSocket proxy
function setupRTSPStream(videoElement, rtspUrl) {
    try {
        // In a real implementation, you would connect to a WebSocket server
        // that proxies the RTSP stream to WebRTC or another web-compatible format
        
        // For this example, we'll simulate it with HLS
        if (Hls.isSupported()) {
            const hls = new Hls({
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
                enableWorker: true,
                lowLatencyMode: true
            });
            
            // Convert RTSP URL to HLS URL (in a real app, this would be handled by the server)
            const hlsUrl = rtspUrl.replace('rtsp://', 'http://').replace('.sdp', '.m3u8');
            
            hls.loadSource(hlsUrl);
            hls.attachMedia(videoElement);
            
            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                videoElement.play()
                    .catch(e => console.warn('Autoplay prevented:', e));
            });
            
            return hls; // Return for cleanup
        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            // Native HLS support (Safari)
            videoElement.src = rtspUrl.replace('rtsp://', 'http://').replace('.sdp', '.m3u8');
            videoElement.play()
                .catch(e => console.warn('Autoplay prevented:', e));
        } else {
            throw new Error('RTSP streaming not supported in this browser');
        }
    } catch (error) {
        console.error('Error setting up RTSP stream:', error);
        throw error;
    }
}

// Add support for MJPEG streaming
function setupMJPEGStream(imgElement, mjpegUrl) {
    try {
        // For MJPEG, we use an img tag with a direct URL to the MJPEG stream
        imgElement.src = mjpegUrl;
        
        // Set up error handling
        imgElement.onerror = () => {
            console.error('Error loading MJPEG stream');
            imgElement.src = '/placeholder.svg';
        };
        
        // Return a cleanup function
        return () => {
            imgElement.src = '';
            imgElement.onerror = null;
        };
    } catch (error) {
        console.error('Error setting up MJPEG stream:', error);
        throw error;
    }
}

// Enhanced function to detect and handle different streaming protocols
function detectStreamType(url) {
    try {
        const lowerUrl = url.toLowerCase();
        
        if (lowerUrl.startsWith('rtsp://') || lowerUrl.includes('.sdp')) {
            return 'rtsp';
        } else if (lowerUrl.endsWith('.m3u8') || lowerUrl.includes('hls')) {
            return 'hls';
        } else if (lowerUrl.includes('mjpeg') || lowerUrl.endsWith('.mjpg')) {
            return 'mjpeg';
        } else if (lowerUrl.includes('webrtc')) {
            return 'webrtc';
        } else if (lowerUrl.endsWith('.mp4') || lowerUrl.endsWith('.webm')) {
            return 'video';
        } else {
            // Default to HTTP stream
            return 'http';
        }
    } catch (error) {
        console.error('Error detecting stream type:', error);
        return 'http'; // Default to HTTP
    }
}

// Enhanced function to load video with proper protocol handling
function loadVideoWithRetry(videoElement, camera, cameraItem, retryCount = 0) {
    const maxRetries = 3;
    
    try {
        const streamType = detectStreamType(camera.feedUrl);
        
        switch (streamType) {
            case 'hls':
                if (Hls.isSupported()) {
                    const hls = new Hls({
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });
                    
                    hls.loadSource(camera.feedUrl);
                    hls.attachMedia(videoElement);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        videoElement.play()
                            .then(() => {
                                cameraItem.classList.remove('loading-camera');
                            })
                            .catch(err => {
                                console.warn('Auto-play prevented:', err);
                                cameraItem.classList.remove('loading-camera');
                            });
                    });
                    
                    hls.on(Hls.Events.ERROR, function(event, data) {
                        if (data.fatal) {
                            console.error("HLS Error:", data);
                            
                            if (retryCount < maxRetries) {
                                console.log(`Retrying HLS stream (${retryCount + 1}/${maxRetries})...`);
                                setTimeout(() => {
                                    hls.destroy();
                                    loadVideoWithRetry(videoElement, camera, cameraItem, retryCount + 1);
                                }, 2000);
                            } else {
                                handleStreamError(camera, cameraItem);
                            }
                        }
                    });
                } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                    // Native HLS support (Safari)
                    videoElement.src = camera.feedUrl;
                    videoElement.addEventListener('loadeddata', () => {
                        cameraItem.classList.remove('loading-camera');
                    });
                    
                    videoElement.addEventListener('error', (e) => {
                        handleVideoError(e, camera, cameraItem, videoElement, retryCount, maxRetries);
                    });
                } else {
                    // No HLS support
                    handleStreamError(camera, cameraItem, "HLS streaming not supported in this browser");
                }
                break;
                
            case 'rtsp':
                // RTSP requires a proxy server in real implementation
                setupRTSPStream(videoElement, camera.feedUrl);
                videoElement.addEventListener('loadeddata', () => {
                    cameraItem.classList.remove('loading-camera');
                });
                
                videoElement.addEventListener('error', (e) => {
                    handleVideoError(e, camera, cameraItem, videoElement, retryCount, maxRetries);
                });
                break;
                
            case 'webrtc':
                // WebRTC setup
                try {
                    setupWebRTCStream(videoElement, camera.feedUrl);
                    videoElement.addEventListener('loadeddata', () => {
                        cameraItem.classList.remove('loading-camera');
                    });
                    
                    videoElement.addEventListener('error', (e) => {
                        handleVideoError(e, camera, cameraItem, videoElement, retryCount, maxRetries);
                    });
                } catch (err) {
                    handleStreamError(camera, cameraItem, "WebRTC streaming error: " + err.message);
                }
                break;
                
            case 'mjpeg':
                // For MJPEG, we need to use an img tag instead of video
                cameraItem.innerHTML = `
                    <img src="${camera.feedUrl}" alt="${camera.name}" loading="lazy" 
                         onerror="this.onerror=null; this.src='/placeholder.svg'; this.parentElement.classList.remove('loading-camera');" 
                         style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
                    <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}"></div>
                    <div class="camera-info">
                        <span class="camera-name">${camera.name}</span>
                        <div class="camera-actions">
                            <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}" aria-label="${camera.recording ? 'Stop Recording' : 'Start Recording'}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="${camera.recording ? 'red' : 'none'}" />
                                </svg>
                            </button>
                            <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-detected' : ''}" data-camera-id="${camera.id}" aria-label="${camera.motion ? 'Stop Motion Detection' : 'Start Motion Detection'}">
                                <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="24" cy="24" r="10" stroke="#00BFFF" stroke-width="3" fill="none" opacity="0.8"/>
                                    <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="#00FFFF" stroke-width="2" fill="none" />
                                    <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="#1E90FF" stroke-width="2" fill="none" opacity="0.6"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                
                const imgElement = cameraItem.querySelector('img');
                if (imgElement) {
                    imgElement.addEventListener('load', () => {
                        cameraItem.classList.remove('loading-camera');
                    });
                }
                break;
                
            default:
                // Regular video
                videoElement.src = camera.feedUrl;
                videoElement.addEventListener('loadeddata', () => {
                    cameraItem.classList.remove('loading-camera');
                });
                
                videoElement.addEventListener('error', (e) => {
                    handleVideoError(e, camera, cameraItem, videoElement, retryCount, maxRetries);
                });
                break;
        }
    } catch (error) {
        console.error('Error loading video:', error);
        handleStreamError(camera, cameraItem, error.message);
    }
}

function handleVideoError(error, camera, cameraItem, videoElement, retryCount, maxRetries) {
    console.error("Video error:", error);
    
    if (retryCount < maxRetries) {
        console.log(`Retrying video load (${retryCount + 1}/${maxRetries})...`);
        setTimeout(() => {
            loadVideoWithRetry(videoElement, camera, cameraItem, retryCount + 1);
        }, 2000);
    } else {
        handleStreamError(camera, cameraItem);
    }
}

function handleStreamError(camera, cameraItem, errorMessage = "Stream error") {
    cameraItem.innerHTML = `
        <img src="/placeholder.svg" alt="${camera.name}" style="transform: scale(${camera.zoom}) translateX(${camera.panX}px) translateY(${camera.panY}px);">
        <div class="camera-overlay"></div>
        <div class="camera-info">
            <span class="camera-name">${camera.name} (Stream Error)</span>
            <div class="camera-actions">
                <button class="camera-action-btn record" data-camera-id="${camera.id}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8" stroke="white" stroke-width="1.5" fill="none" />
                    </svg>
                </button>
            </div>
        </div>`;
    cameraItem.classList.remove('loading-camera');
    console.error(errorMessage);
}
</script>
</body>
</html>