<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Cam App</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600;700&family=Audiowide&family=Exo+2:wght@100;200;300;400;500;600;700&family=Syncopate:wght@400;700&display=swap"
        rel="stylesheet">
    <!-- GSAP for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <!-- HLS.js for HLS streaming -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
    <!-- WebRTC adapter for cross-browser compatibility (good practice even if not directly using complex WebRTC features yet) -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
             height: -webkit-fill-available; /* iOS Safari height fix */
        }

        body {
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS Safari height fix */
            overflow-x: hidden;
            font-family: 'Rajdhani', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation; /* Allow scrolling but prevent double-tap zoom etc */
             -webkit-tap-highlight-color: transparent; /* Remove blue tap highlight */
        }

        .app {
            width: 100%;
            max-width: 480px; /* Mobile-first approach */
            height: 100vh; /* Full viewport height */
            max-height: -webkit-fill-available; /* iOS Safari height fix */
            position: relative;
            overflow: hidden;
            background-color: #f0f0f0; /* Base background */
             border-radius: clamp(10px, 3vw, 20px); /* Optional rounding */
             box-shadow: 0 10px 30px rgba(0,0,0,0.2); /* Optional shadow */
        }

        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            background-color: white; /* Default page background */
            display: flex;
            flex-direction: column;
        }

        /* Landing Page Styles */
        .landing-page {
            background-color: #e8f3e9;
            border-radius: clamp(20px, 4vw, 32px);
            padding: clamp(16px, 4vw, 24px);
        }

        .security-badge {
            position: absolute;
            top: clamp(32px, 6vw, 48px);
            left: 50%;
            transform: translateX(-50%);
            width: clamp(56px, 10vw, 80px);
            height: clamp(56px, 10vw, 80px);
            border-radius: 50%;
            background-color: #d5e6d7;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .security-badge::before {
            content: '';
            width: clamp(44px, 8vw, 64px);
            height: clamp(44px, 8vw, 64px);
            border-radius: 50%;
            background-color: #c5dcc7;
        }

        .security-badge::after {
            content: '';
            position: absolute;
            width: clamp(32px, 6vw, 48px);
            height: clamp(32px, 6vw, 48px);
            border-radius: 50%;
            background-color: #b5d2b7;
        }

        .security-badge svg {
            position: relative;
            z-index: 1;
            width: clamp(16px, 3vw, 24px);
            height: clamp(16px, 3vw, 24px);
            color: #95b897;
        }

        .landing-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin-top: clamp(60px, 16vw, 96px);
            gap: clamp(16px, 4vw, 24px);
        }

        .camera-image {
            width: 100%;
            height: clamp(120px, 30vw, 192px);
            background-image: url('placeholder.svg'); /* Use placeholder or actual icon */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .landing-title {
            font-size: clamp(32px, 8vw, 42px);
            font-weight: 800;
            line-height: 1.1;
            letter-spacing: -0.02em;
            font-family: 'Orbitron', sans-serif;
        }

        .landing-subtitle {
            font-size: clamp(12px, 3vw, 14px);
            color: #4b5563;
            font-weight: 500;
            font-family: 'Exo 2', sans-serif;
        }

        .get-started-btn {
            width: 100%;
            background-color: black;
            color: white;
            border: none;
            border-radius: 9999px;
            padding: clamp(12px, 4vw, 16px) clamp(16px, 5vw, 24px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            margin-top: auto; /* Push to bottom */
             margin-bottom: clamp(20px, 5vh, 50px);
            box-shadow: 0 clamp(6px, 2vw, 10px) clamp(10px, 3vw, 15px) -3px rgba(0, 0, 0, 0.1), 0 clamp(3px, 1vw, 4px)
                clamp(4px, 2vw, 6px) -2px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            font-family: 'Audiowide', cursive;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .get-started-btn:hover {
            transform: scale(1.05);
        }

        .get-started-btn:active {
            transform: scale(0.95);
        }

        /* Home Page Styles */
        .home-page {
            border-radius: clamp(20px, 4vw, 32px); /* May be hidden by .app rounding */
            padding: clamp(16px, 4vw, 20px);
            padding-bottom: 5px; /* Space below content */
        }

        .home-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: clamp(10px, 3vw, 16px);
            margin-bottom: clamp(16px, 4vw, 24px);
            flex-shrink: 0; /* Prevent header shrinking */
        }

        .cams-connected {
            display: flex;
            align-items: center;
            gap: clamp(4px, 2vw, 8px);
            min-width: 0; /* Allow shrinking */
        }

        .cameras-icon {
            width: clamp(24px, 6vw, 32px);
            height: clamp(24px, 6vw, 32px);
            border-radius: 50%;
            background-color: black;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            flex-shrink: 0;
        }

        .cameras-icon:hover {
            transform: scale(1.1);
        }

        .cams-connected-text {
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            font-family: 'Exo 2', sans-serif;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

         .header-actions {
             display: flex;
             gap: clamp(8px, 3vw, 12px);
             align-items: center;
             flex-shrink: 0;
         }

        .add-cam-btn { /* Also applies to recordingsBtn now */
            width: clamp(28px, 7vw, 36px); /* Slightly larger */
            height: clamp(28px, 7vw, 36px);
            border-radius: 50%;
            background-color: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55), background-color 0.2s;
            flex-shrink: 0;
        }
         .add-cam-btn svg {
              width: clamp(16px, 4vw, 20px);
              height: clamp(16px, 4vw, 20px);
              display: block;
         }

        .add-cam-btn:hover {
            transform: scale(1.1);
             background-color: #e5e7eb;
        }
         .add-cam-btn:active {
            transform: scale(0.95);
         }

        /* Search Bar Styles */
        .search-container {
             margin-bottom: clamp(12px, 4vw, 18px);
             padding: 0 2px; /* Slight horizontal padding */
             position: relative;
             flex-shrink: 0;
         }
        .search-container input[type="search"] {
             width: 100%;
             padding: clamp(8px, 2.5vw, 10px) clamp(12px, 3vw, 15px);
             padding-left: clamp(30px, 8vw, 35px); /* Space for icon */
             border: 1px solid #ddd;
             border-radius: 9999px;
             font-family: 'Exo 2', sans-serif;
             font-size: clamp(13px, 3vw, 14px);
             transition: border-color 0.2s, box-shadow 0.2s;
             -webkit-appearance: none; /* Remove default search styling */
             appearance: none;
         }
         .search-container input[type="search"]::-webkit-search-decoration,
         .search-container input[type="search"]::-webkit-search-cancel-button,
         .search-container input[type="search"]::-webkit-search-results-button,
         .search-container input[type="search"]::-webkit-search-results-decoration {
             -webkit-appearance: none; /* Remove internal chrome icons */
         }

         .search-container input[type="search"]:focus {
             border-color: #aaa;
             box-shadow: 0 0 0 2px rgba(0,0,0,0.05);
             outline: none;
         }
         .search-container::before { /* Search Icon */
             content: '';
             position: absolute;
             left: clamp(10px, 2.5vw, 12px);
             top: 50%;
             transform: translateY(-50%);
             width: clamp(16px, 4vw, 18px);
             height: clamp(16px, 4vw, 18px);
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='2' stroke='%23888'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z' /%3E%3C/svg%3E");
             background-size: contain;
             background-repeat: no-repeat;
             opacity: 0.6;
             pointer-events: none; /* Allow clicks through */
         }


        .tabs {
            display: flex;
            gap: clamp(8px, 3vw, 12px);
            margin-bottom: clamp(16px, 5vw, 24px);
            overflow-x: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE 10+ */
            padding-bottom: 5px; /* Space for scrollbar if visible */
             flex-shrink: 0;
             -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        .tabs::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }

        .tab {
            padding: clamp(4px, 2vw, 6px) clamp(10px, 4vw, 16px); /* More padding */
            border-radius: 9999px;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            white-space: nowrap;
            border: 1px solid transparent; /* Base border */
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            background-color: #f3f4f6;
            color: black;
             font-family: 'Exo 2', sans-serif;
        }

        .tab:hover {
            transform: scale(1.05);
             background-color: #e5e7eb;
        }

        .tab.active {
            background-color: black;
            color: white;
            border-color: black;
             transform: scale(1.02); /* Slight scale for active */
        }

        .camera-list {
            flex: 1; /* Take remaining space */
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            position: relative;
            padding-right: 5px; /* Prevent content touching edge */
            padding-left: 2px;
             -webkit-overflow-scrolling: touch;
        }

        .camera-list::-webkit-scrollbar {
            display: none;
        }

         .camera-list.empty-state .empty-state-text,
         #recordingsList.empty-state .empty-state-text {
             display: block; /* Show text when empty */
             position: absolute;
             top: 40%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-size: clamp(16px, 4vw, 18px);
             color: #999;
             text-align: center;
             font-family: 'Exo 2', sans-serif;
             padding: 0 15px; /* Prevent text touching edges */
             width: 90%;
         }
         .camera-list:not(.empty-state) .empty-state-text,
         #recordingsList:not(.empty-state) .empty-state-text {
             display: none; /* Hide text when not empty */
         }

        .camera-item {
            position: relative;
            aspect-ratio: 16 / 9; /* More standard ratio */
            border-radius: clamp(16px, 4vw, 20px); /* Slightly smaller radius */
            overflow: hidden;
            margin-bottom: clamp(12px, 4vw, 16px);
            box-shadow: 0 clamp(3px, 1vw, 4px) clamp(4px, 2vw, 6px) -1px rgba(0, 0, 0, 0.1),
                0 clamp(2px, 1vw, 3px) clamp(2px, 1vw, 4px) -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            cursor: pointer;
             background-color: #e0e0e0; /* Placeholder background */
        }

        .camera-item:hover {
            transform: scale(1.02);
        }

        /* Video/Image Wrapper */
         .camera-item .video-wrapper,
         .camera-feed .video-wrapper {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             overflow: hidden;
             border-radius: inherit;
             background-color: #333; /* Dark bg for video */
         }
          .camera-off-placeholder {
              display: flex; flex-direction: column; /* Allow small text below */ align-items: center; justify-content: center; background: #333; color: #aaa; font-family: 'Exo 2', sans-serif; height: 100%; text-align: center; padding: 5px; font-size: clamp(12px, 3vw, 14px);
          }
           .camera-off-placeholder span small { font-size: 0.8em; color: #888; display: block; margin-top: 3px;}

         /* Enhanced Status Indicator Styles */
         .list-item-status {
             position: absolute;
             top: 8px;
             right: 8px;
             background-color: rgba(0, 0, 0, 0.6);
             color: white;
             font-size: clamp(9px, 2vw, 11px);
             padding: 3px 6px;
             border-radius: 4px;
             font-family: 'Exo 2', sans-serif;
             z-index: 8; /* Above video/img, below controls */
             opacity: 0; /* Hidden by default */
             transition: opacity 0.3s ease, background-color 0.3s ease;
         }
         .list-item-status.visible { opacity: 0.9; }
         .list-item-status.status-offline { background-color: rgba(100, 100, 100, 0.7); color: #eee; }
         .list-item-status.status-connecting { background-color: rgba(255, 165, 0, 0.7); color: white; } /* Orange */
         .list-item-status.status-error { background-color: rgba(220, 50, 50, 0.7); color: white; } /* Red */


        .camera-item video,
        .camera-feed video,
        .camera-item img,
        .camera-feed img {
            position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             object-fit: cover;
             display: block;
             transition: transform 0.3s ease, opacity 0.3s ease; /* Smooth zoom/pan & fade-in */
        }

         /* --- Recording Indicator Animation --- */
         .recording-active::before {
             content: '';
             position: absolute;
             top: 0;
             left: 0;
             right: 0;
             bottom: 0;
             border-radius: inherit; /* Match parent's border-radius */
             border: 3px solid red;
             /* iOS 18 Siri like glow - multiple shadows */
             box-shadow: 0 0 5px rgba(255, 0, 0, 0.7),
                         0 0 10px rgba(255, 0, 0, 0.5),
                         inset 0 0 5px rgba(255, 0, 0, 0.3);
             animation: pulse-red 1.5s infinite ease-in-out;
             pointer-events: none; /* Allow clicks through */
             z-index: 5; /* Above video, below controls */
         }

         @keyframes pulse-red {
             0%, 100% {
                 opacity: 0.7;
                 transform: scale(1);
                 box-shadow: 0 0 5px rgba(255, 0, 0, 0.7),
                             0 0 10px rgba(255, 0, 0, 0.5),
                             inset 0 0 5px rgba(255, 0, 0, 0.3);
             }
             50% {
                 opacity: 1;
                 transform: scale(1.015); /* Slightly more noticeable scale */
                 box-shadow: 0 0 10px rgba(255, 0, 0, 1),
                             0 0 20px rgba(255, 0, 0, 0.8),
                             inset 0 0 10px rgba(255, 0, 0, 0.5);
             }
         }
         /* --- End Recording Indicator --- */


        .camera-item .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 6; /* Above recording indicator */
             background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0) 40%); /* Subtle bottom gradient */
             opacity: 1; /* Always visible for gradient */
             transition: opacity 0.3s ease;
        }
         .camera-overlay-text { /* Class for text within overlay */
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             color: white;
             background: rgba(0, 0, 0, 0.7);
             padding: clamp(4px, 1.5vw, 6px) clamp(8px, 3vw, 12px);
             border-radius: 9999px;
             font-size: clamp(11px, 2.5vw, 13px);
             font-family: 'Audiowide', cursive;
             opacity: 0; /* Hidden by default */
             transition: opacity 0.3s ease;
             border: 1px solid transparent;
             text-align: center;
             line-height: 1.2;
         }
         .camera-item .camera-overlay.motion-detected-overlay .camera-overlay-text {
              /* Text content set via JS */
              opacity: 1;
              color: yellow;
              border-color: yellow;
         }
         .camera-item .camera-overlay.camera-off .camera-overlay-text {
              /* Using placeholder div instead now */
              opacity: 0; /* Hide this text if placeholder is visible */
         }

        .camera-info {
            position: absolute;
            bottom: clamp(8px, 2.5vw, 12px); /* Slightly higher */
            left: clamp(8px, 2.5vw, 12px);
            right: clamp(8px, 2.5vw, 12px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 7; /* Above overlay gradient */
        }

        .camera-name {
            color: white;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 600; /* Bolder */
            font-family: 'Exo 2', sans-serif;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8); /* Stronger shadow */
            background: rgba(0, 0, 0, 0.4); /* Slightly darker bg */
            padding: 5px 10px; /* More padding */
            border-radius: 6px; /* More rounded */
            backdrop-filter: blur(5px);
             max-width: 60%; /* Prevent overlapping actions */
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
        }

        .camera-actions {
            display: flex;
            gap: clamp(5px, 2vw, 8px); /* Slightly more gap */
        }

        .camera-action-btn {
            width: clamp(32px, 8vw, 38px); /* Slightly larger */
            height: clamp(32px, 8vw, 38px); /* Slightly larger */
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.4); /* Match name bg */
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55), background-color 0.2s, display 0s; /* Added display */
             color: white; /* Ensure icons are white */
             padding: clamp(5px, 1.5vw, 7px); /* Increased padding for larger touch area */
             position: relative; /* Needed for potential ::before */
        }
        .camera-action-btn svg {
             width: clamp(14px, 4vw, 18px); /* Adjust icon size */
             height: clamp(14px, 4vw, 18px);
             display: block;
             pointer-events: none; /* Make sure clicks go to the button */
        }

        .camera-action-btn:hover {
            transform: scale(1.1);
             background-color: rgba(0, 0, 0, 0.6);
        }
         .camera-action-btn:active {
            transform: scale(0.95);
         }

        .camera-action-btn.recording { /* Style for recording state */
            background-color: rgba(255, 0, 0, 0.7);
        }
        .camera-action-btn.recording svg circle {
             fill: white; /* Fill circle white when recording */
        }


        /* Motion Detection Icon Styling */
         .camera-action-btn.motion-detection svg {
             width: 20px;
             height: 20px;
             stroke-width: 1.5;
             transition: stroke 0.3s ease, opacity 0.3s ease; /* Added opacity transition */
         }
         .camera-action-btn.motion-detection svg * { /* Apply transition to children too */
             transition: stroke 0.3s ease, opacity 0.3s ease;
         }

         /* Active motion detected */
         .camera-action-btn.motion-detection.motion-active svg {
            animation: pulse-motion-icon 1s infinite alternate;
         }
         /* Motion detection enabled */
         .camera-item.motion-enabled .motion-detection svg circle,
         .camera-item.motion-enabled .motion-detection svg path {
             /* Style set by updateMotionUI JS based on data attributes */
         }
         /* Motion detection disabled */
         .camera-item:not(.motion-enabled) .motion-detection svg circle,
         .camera-item:not(.motion-enabled) .motion-detection svg path {
             /* Style set by updateMotionUI JS */
         }

         @keyframes pulse-motion-icon {
           from { stroke: #00BFFF; } /* Or colors from SVG */
           to { stroke: yellow; }
         }


        /* Camera Page Styles */
        .camera-page {
            background-color: black; /* Full black background */
            border-radius: 0; /* No radius for full screen feel */
            position: relative;
            overflow: hidden; /* Ensure controls stay within */
             touch-action: pan-y; /* Allow vertical scroll if needed, prevent horizontal pan interfering with swipe */
        }

        .camera-feed {
            width: 100%;
            height: 100%;
            background-color: #111; /* Dark background */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for overlays */
        }

        .camera-feed.loading::before {
            content: 'Connecting...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(16px, 4vw, 18px);
            color: #ccc;
            text-align: center;
             font-family: 'Exo 2', sans-serif;
             z-index: 1;
        }

        .live-indicator { /* Class added via JS */
            position: absolute;
            top: clamp(15px, 4vw, 20px);
            left: clamp(15px, 4vw, 20px);
            padding: clamp(5px, 2vw, 8px) clamp(10px, 4vw, 16px);
            border-radius: 9999px;
            backdrop-filter: blur(10px);
            color: white;
            font-size: clamp(11px, 2.5vw, 13px);
            font-weight: 500;
            font-family: 'Audiowide', cursive;
            z-index: 10;
             display: inline-flex; /* Use flex */
             align-items: center;
             gap: 5px;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3);
             opacity: 0; /* Hidden initially, shown via class */
             transition: opacity 0.3s ease, background-color 0.3s ease;
        }
         .camera-feed.live .live-indicator {
             opacity: 1;
             background-color: rgba(255, 0, 0, 0.8); /* Red for live */
             /* content handled by JS */
         }
         .camera-feed.live-off .live-indicator {
             opacity: 1;
             background-color: rgba(100, 100, 100, 0.8); /* Grey for off */
             /* content handled by JS */
         }


        .camera-header {
            position: absolute;
            top: 0; /* Align with top */
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between; /* Keeps back button left, group right */
            align-items: center;
            padding: clamp(15px, 4vw, 20px); /* Consistent padding */
             margin-top: 0; /* Remove margin */
             z-index: 20; /* Above everything else */
             pointer-events: none; /* Allow clicks through */
        }
         .camera-header > * {
             pointer-events: auto; /* Enable pointer events for children */
         }

        /* NEW: Wrapper for Timer and Protocol Selector */
         .header-timer-protocol {
             display: flex;
             align-items: center;
             gap: clamp(8px, 2vw, 12px); /* Space between timer and selector */
         }

        .back-btn {
            width: clamp(36px, 9vw, 44px); /* Larger tap target */
            height: clamp(36px, 9vw, 44px);
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3); /* Darker semi-transparent */
            backdrop-filter: blur(15px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55), background-color 0.2s;
             box-shadow: 0 2px 5px rgba(0,0,0,0.2);
             flex-shrink: 0; /* Prevent shrinking */
        }
         .back-btn svg {
              width: clamp(20px, 5vw, 24px);
              height: clamp(20px, 5vw, 24px);
              stroke: white;
              display: block;
         }

        .back-btn:hover {
            transform: scale(1.1);
             background-color: rgba(0, 0, 0, 0.5);
        }
         .back-btn:active {
             transform: scale(0.95);
         }


        .timer {
            padding: clamp(5px, 2vw, 8px) clamp(10px, 4vw, 16px);
            border-radius: 9999px;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(15px);
            color: white;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 500;
            font-family: 'Audiowide', cursive;
             border: 1px solid rgba(255, 255, 255, 0.1);
             box-shadow: 0 2px 5px rgba(0,0,0,0.2);
             transition: background-color 0.3s ease;
             flex-shrink: 0; /* Prevent shrinking */
        }

        /* Custom Camera Controls Styles */
        .controls-container {
            position: absolute;
            bottom: clamp(20px, 5vh, 40px); /* Position relative to bottom */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(15px, 3vw, 25px); /* Wider gap */
            padding: clamp(10px, 2vw, 15px); /* Less vertical padding */
             z-index: 15; /* Above feed, below header */
             width: 90%; /* Take more width */
             max-width: 400px;
             background-color: rgba(0, 0, 0, 0.2); /* Subtle bg */
             backdrop-filter: blur(10px);
             border-radius: 9999px; /* Pill shape */
             border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .d-pad {
            position: relative;
            width: clamp(100px, 22vw, 140px); /* Slightly smaller */
            height: clamp(100px, 22vw, 140px);
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            box-shadow: inset 1px 1px 3px rgba(255,255,255,0.2), inset -1px -1px 3px rgba(0,0,0,0.3); /* Neumorphic inset */
        }

        .d-pad-button {
            position: absolute;
            width: clamp(30px, 7vw, 36px); /* Adjust size */
            height: clamp(30px, 7vw, 36px);
            background-color: rgba(255, 255, 255, 0.15); /* Slightly lighter */
            backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(18px, 4vw, 22px); /* Adjust font size */
            color: #ffffff;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3), -1px -1px 3px rgba(255,255,255,0.1); /* Neumorphic outset */
            transition: all 0.15s ease-out;
            cursor: pointer;
        }

        .d-pad-button:active {
             box-shadow: inset 1px 1px 3px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.1); /* Pressed effect */
             transform: scale(0.95);
        }

        .up { top: 8px; left: 50%; transform: translateX(-50%); }
        .right { right: 8px; top: 50%; transform: translateY(-50%); }
        .down { bottom: 8px; left: 50%; transform: translateX(-50%); }
        .left { left: 8px; top: 50%; transform: translateY(-50%); }

         /* Icons using characters (replace with SVG for better visuals) */
         .up::after { content: '+'; font-size: 20px; line-height: 1; } /* Zoom In */
         .down::after { content: '−'; font-size: 20px; line-height: 1; } /* Zoom Out */
         .left::after { content: '◀'; font-size: 16px; line-height: 1; } /* Pan Left */
         .right::after { content: '▶'; font-size: 16px; line-height: 1; } /* Pan Right */

        .center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(35px, 8vw, 45px); /* Adjust size */
            height: clamp(35px, 8vw, 45px);
            background-color: transparent;
            border-radius: 50%;
            box-shadow: inset 1px 1px 3px rgba(255,255,255,0.2), inset -1px -1px 3px rgba(0,0,0,0.3);
        }

        .side-button {
            width: clamp(40px, 9vw, 50px); /* Match d-pad button style */
            height: clamp(40px, 9vw, 50px);
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #ffffff;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3), -1px -1px 3px rgba(255,255,255,0.1);
            transition: all 0.15s ease-out;
            cursor: pointer;
        }
         .side-button svg {
             width: clamp(20px, 5vw, 24px);
             height: clamp(20px, 5vw, 24px);
             stroke-width: 1.5; /* Thinner lines for icons */
             display: block;
         }
          /* Mute line styling */
          .mute-btn #muteLine {
              stroke: red;
              stroke-width: 2;
              transition: display 0s; /* Instant show/hide */
          }

        .side-button:active {
             box-shadow: inset 1px 1px 3px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.1);
             transform: scale(0.95);
        }

        /* End Custom Camera Control Styles */

        /* Modal Styles */
        .modal, .confirmation-modal, .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Darker backdrop */
            display: flex;
            justify-content: center;
            align-items: center; /* Center vertically */
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            padding: 15px; /* Padding around modal */
        }

        .modal.active, .confirmation-modal.active, .settings-modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background-color: white;
            padding: clamp(16px, 4vw, 24px); /* More padding */
            border-radius: clamp(12px, 4vw, 16px); /* More rounded */
            max-width: 400px; /* Default max-width for mobile */
            width: 100%; /* Use max-width to control size */
            position: relative;
            transform: translateY(-20px) scale(0.95);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 0;
             box-shadow: 0 5px 20px rgba(0,0,0,0.2);
             display: flex; /* Enable flex for children */
             flex-direction: column;
             max-height: 90vh; /* Prevent modal overflowing viewport */
        }

         .modal-body { /* New wrapper for scrollable content */
             overflow-y: auto;
             padding-right: 5px; /* Space for scrollbar */
             flex-grow: 1; /* Take available space */
             margin-bottom: 15px; /* Space before buttons */
             scrollbar-width: thin;
             scrollbar-color: #ccc #eee;
         }
          .modal-body::-webkit-scrollbar { width: 5px; }
          .modal-body::-webkit-scrollbar-track { background: #eee; border-radius: 3px;}
          .modal-body::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }

         .modal.active .modal-content,
         .confirmation-modal.active .modal-content,
         .settings-modal.active .modal-content {
            transform: translateY(0) scale(1);
             opacity: 1;
         }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: clamp(16px, 4vw, 20px); /* More space */
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            flex-shrink: 0; /* Prevent header shrinking */
        }

        .modal-header h2 {
            font-size: clamp(18px, 4.5vw, 22px); /* Slightly larger */
            font-family: 'Orbitron', sans-serif;
            color: #333;
            margin-right: 10px; /* Space before close button */
        }

        .modal-close {
            background-color: transparent;
            border: none;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            padding: 5px; /* Easier to tap */
             color: #888;
             flex-shrink: 0;
        }
        .modal-close:hover {
            transform: scale(1.1) rotate(90deg);
             color: #333;
        }
        .modal-close svg {
            width: clamp(20px, 5vw, 24px);
            height: clamp(20px, 5vw, 24px);
            display: block;
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: clamp(12px, 4vw, 18px); /* More gap */
        }
        .modal-footer { /* Container for modal buttons */
             flex-shrink: 0; /* Prevent shrinking */
             margin-top: auto; /* Push to bottom if content is short */
             padding-top: 10px; /* Space above buttons */
             display: flex;
             flex-direction: column; /* Stack buttons by default */
             gap: 10px;
        }

        .modal-form input[type="text"],
        .modal-form input[type="number"],
        .modal-form select {
            padding: clamp(10px, 3vw, 14px); /* More padding */
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
             font-size: clamp(14px, 3.5vw, 16px);
             transition: border-color 0.2s, box-shadow 0.2s;
             width: 100%; /* Ensure full width */
        }
         .modal-form input:focus, .modal-form select:focus {
             border-color: #555;
             box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
             outline: none;
         }


        .modal-footer button, /* Target buttons in footer */
        .modal-form button[type="submit"],
        .modal-form button[type="button"] { /* Keep styling for buttons directly in form if any */
            background-color: black;
            color: white;
            border: none;
            border-radius: 9999px;
            padding: clamp(10px, 3.5vw, 14px) clamp(16px, 5vw, 24px);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 500;
            box-shadow: 0 clamp(4px, 1.5vw, 6px) clamp(8px, 2.5vw, 12px) -3px rgba(0, 0, 0, 0.1),
                0 clamp(2px, 1vw, 4px) clamp(3px, 1.5vw, 5px) -2px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            font-family: 'Audiowide', cursive;
             font-size: clamp(14px, 3.5vw, 16px);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55), background-color 0.2s;
             /* margin-top: 10px; Remove top margin here */
             width: 100%; /* Make buttons full width */
        }

        .modal-footer button:hover {
            transform: scale(1.05);
             background-color: #333;
        }

        .modal-footer button:active {
            transform: scale(0.95);
        }
         .modal-footer button[style*="red"],
         .modal-form button[style*="red"] {
             background-color: #F44336;
         }
         .modal-footer button[style*="red"]:hover,
         .modal-form button[style*="red"]:hover {
             background-color: #cc0000;
         }

        /* Toast Styles */
        .toast {
            position: fixed;
            bottom: 20px; /* Position at bottom */
            left: 50%;
            transform: translateX(-50%) translateY(60px); /* Start off screen below */
            background-color: #333;
            color: white;
            padding: 12px 18px; /* More padding */
            border-radius: 8px; /* More rounded */
            z-index: 1100;
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bounce effect */
            pointer-events: none;
             font-family: 'Exo 2', sans-serif;
             font-size: clamp(13px, 3vw, 15px);
             box-shadow: 0 3px 10px rgba(0,0,0,0.2);
             max-width: 90%;
             text-align: center;
        }

        .toast.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }

        .toast.success { background-color: #4CAF50; }
        .toast.error { background-color: #F44336; }
        .toast.warning { background-color: #FF9800; }
        .toast.info { background-color: #2196F3; }

        /* Confirmation Modal Styles */
        .confirmation-modal .modal-content {
             max-width: 350px;
             max-height: none; /* Override max-height */
        }
         .confirmation-modal .modal-body { overflow-y: visible; margin-bottom: 0;} /* Override scroll */
         .confirmation-modal p {
              text-align: center;
              margin-bottom: 25px; /* More space */
              font-family: 'Exo 2', sans-serif;
              color: #555;
              font-size: clamp(15px, 4vw, 17px);
              line-height: 1.4;
         }
        .confirmation-modal .modal-footer { /* Buttons side-by-side */
            flex-direction: row;
            gap: clamp(10px, 3vw, 16px);
            justify-content: center;
             margin-top: 0; /* Remove extra top margin */
        }
         .confirmation-modal .modal-footer button {
             padding: clamp(8px, 3vw, 12px) clamp(15px, 5vw, 25px); /* Adjust padding */
             flex: 1; /* Make buttons take equal space */
             max-width: 140px;
             margin-top: 0;
             width: auto; /* Override full width from modal-form button */
         }
         #confirmDeleteBtn { background-color: #F44336; }
         #confirmDeleteBtn:hover { background-color: #d32f2f; }
         #cancelDeleteBtn { background-color: #ccc; color: #333;}
         #cancelDeleteBtn:hover { background-color: #bbb; }


        /* Settings Modal Styles */
         .settings-modal .modal-form input[type='checkbox'] {
             width: 18px; /* Adjust size */
             height: 18px;
             margin-right: 10px;
             accent-color: black; /* Style checkbox color */
             cursor: pointer;
             flex-shrink: 0;
         }
        /* Style for disabled checkbox label */
        .settings-modal .modal-form .form-group1 input[type='checkbox']:disabled + label {
            color: #aaa;
            cursor: not-allowed;
        }

         .settings-modal .modal-form .form-group1 {
             display: flex;
             align-items: center;
             background-color: #f9f9f9;
             padding: 12px; /* More padding */
             border-radius: 8px;
             border: 1px solid #eee;
         }
          .settings-modal .modal-form .form-group1 label {
              font-family: 'Exo 2', sans-serif;
              font-size: clamp(14px, 3.5vw, 16px);
              color: #555;
              cursor: pointer;
              flex-grow: 1;
              line-height: 1.3;
          }


        /* Category Modal Styles */
        #categoryModal .modal-content { max-width: 350px; }
        /* Uses default stacked button styles in modal-footer */

        /* Camera item loading placeholder */
        .camera-item.loading-camera .video-wrapper::after { /* Use ::after for overlay */
            content: ''; /* Content set by status div */
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(51, 51, 51, 0.8); /* Dark overlay */
            font-size: clamp(14px, 4vw, 16px);
            color: #ccc;
            text-align: center;
            z-index: 8; /* Above wrapper content */
            font-family: 'Exo 2', sans-serif;
            border-radius: inherit;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        .camera-item:not(.loading-camera) .video-wrapper::after {
             opacity: 0;
             pointer-events: none;
        }
         /* Hide media elements while loading */
         .camera-item.loading-camera .video-wrapper video,
         .camera-item.loading-camera .video-wrapper img {
              opacity: 0;
         }

        /* Connection status indicator */
        .connection-status {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: white;
            z-index: 1050; /* Below modals, above content */
            opacity: 0;
            transition: opacity 0.5s ease, background-color 0.3s, transform 0.5s ease;
             font-family: 'Exo 2', sans-serif;
             box-shadow: 0 2px 5px rgba(0,0,0,0.2);
             pointer-events: none; /* Prevent interaction */
        }
        .connection-status.visible {
             opacity: 1;
             transform: translateX(-50%) translateY(0);
        }
        .connection-status.online { background-color: #4CAF50; }
        .connection-status.offline { background-color: #F44336; transform: translateX(-50%) translateY(0) !important; /* Stay visible when offline */ }
        .connection-status.reconnecting { background-color: #FF9800; }

        /* Stream error overlay on Camera Page */
        .stream-error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 9; /* Below controls/header */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
             text-align: center;
             padding: 20px;
        }
        .stream-error-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
         .stream-error-overlay h3 {
              font-family: 'Orbitron', sans-serif;
              margin-bottom: 15px;
              font-size: clamp(18px, 4vw, 20px);
              color: #ffdddd;
         }
         .stream-error-overlay p {
             font-family: 'Exo 2', sans-serif;
              font-size: clamp(14px, 3.5vw, 16px);
              margin-bottom: 20px;
              line-height: 1.5;
              max-width: 300px;
         }
        .stream-error-overlay button {
            margin-top: 10px;
            padding: 10px 20px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
             font-family: 'Audiowide', cursive;
             transition: background-color 0.2s, transform 0.2s;
        }
         .stream-error-overlay button:hover {
             background-color: #1976D2;
             transform: scale(1.05);
         }
        .stream-error-overlay button.dismiss {
            background-color: #f44336;
            margin-bottom:30px;
        }
          .stream-error-overlay button.dismiss:hover {
             background-color: #d32f2f;
         }

        /* Protocol selector styles */
        .protocol-selector {
             /* Removed absolute positioning */
            position: relative; /* Needed if using pseudo-elements, but not needed now */
            z-index: 10;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .protocol-selector select {
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(15px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: clamp(4px, 1.5vw, 6px) clamp(8px, 2vw, 10px);
            font-size: clamp(11px, 2.5vw, 13px);
            font-family: 'Exo 2', sans-serif;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
             appearance: none; /* Remove default arrow */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8' fill='none'%3E%3Cpath d='M1 1L6 6L11 1' stroke='white' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E"); /* Custom arrow */
             background-repeat: no-repeat;
             background-position: right 8px center;
             padding-right: 25px; /* Space for custom arrow */
             cursor: pointer;
             height: 100%; /* Match timer height if possible */
             max-height: 34px; /* Limit height */
        }
        .protocol-selector select option {
            background-color: #333;
            color: white;
        }

        /* Stream Protocol Form Group in Modal */
        .form-group {
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .form-group select { /* Styles already covered by .modal-form select */
             appearance: none; /* Remove default arrow */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8' fill='none'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23555' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E"); /* Custom arrow (darker) */
             background-repeat: no-repeat;
             background-position: right 12px center;
             padding-right: 35px; /* Space for custom arrow */
             cursor: pointer;
        }
        .form-group label {
            position: absolute;
            top: -10px; /* Position above */
            left: 10px;
            background-color: white; /* Match modal background */
            color: #555;
            font-size: 11px; /* Smaller label */
            font-family: 'Exo 2', sans-serif;
            padding: 1px 6px;
            border-radius: 4px;
             font-weight: 500;
        }

        /* Recordings Page Styles */
         #recordingsPage {
             background-color: #f0f0f0; /* Lighter background */
             /* Added touch-action for swipe */
             touch-action: pan-y;
         }
         #recordingsPage .home-header { /* Adjust header for recordings page */
              background-color: white;
              padding: clamp(10px, 3vw, 15px) clamp(16px, 4vw, 20px);
              margin: 0; /* Remove margins */
              border-bottom: 1px solid #eee;
              border-radius: 10px; /* Remove radius */
              box-shadow: 0 2px 4px rgba(0,0,0,0.05);
              flex-wrap: wrap; /* Allow wrapping for search bar */
         }
         #recordingsPage .back-btn {
              background-color: rgba(0,0,0,0.05);
              backdrop-filter: none;
              border: 1px solid #ddd;
         }
          #recordingsPage .back-btn svg {
              stroke: #555; /* Darker arrow */
          }
          #recordingsPage h2 {
               font-family: 'Orbitron', sans-serif;
               flex-grow: 1;
               text-align: center;
               font-size: clamp(18px, 4vw, 20px);
               color: #333;
               margin: 0 clamp(10px, 2vw, 20px); /* Add horizontal margin */
               overflow: hidden;
               text-overflow: ellipsis;
               white-space: nowrap;
          }
         #recordingsPage .search-container { /* Style search specifically for recordings header */
              order: 3; /* Place below title/buttons */
              width: 100%; /* Full width */
              margin-top: clamp(10px, 3vw, 15px); /* Space above search */
              margin-bottom: 0; /* Remove bottom margin */
              padding: 0;
          }

         /* Style for recordings list items */
         .recording-item {
             background-color: white;
             border-radius: 10px; /* Slightly less rounded */
             padding: 12px 15px;
             margin: 0 2px 10px 2px; /* Add horizontal margin */
             margin-top:10px;
             display: flex;
             justify-content: space-between;
             align-items: center;
             box-shadow: 0 1px 3px rgba(0,0,0,0.08);
             cursor: pointer;
             transition: transform 0.2s ease, box-shadow 0.2s ease;
         }
         .recording-item:hover {
             transform: translateY(-2px);
             box-shadow: 0 3px 6px rgba(0,0,0,0.1);
         }
         .recording-info {
              flex-grow: 1; /* Allow info to take space */
              min-width: 0; /* Prevent overflow issues */
              margin-right: 10px; /* Space before actions */
         }
         .recording-info span {
             display: block;
             color: #555;
         }
          .recording-info .rec-name {
            font-weight: 600;
            font-family: 'Exo 2', sans-serif;
            margin-bottom: 4px;
             font-size: clamp(14px, 3.5vw, 16px);
             color: #333;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
         }
          .recording-info .rec-date,
          .recording-info .rec-duration {
             font-size: clamp(11px, 2.5vw, 12px);
             color: #777;
         }
         .recording-actions {
             flex-shrink: 0; /* Prevent actions button from shrinking */
         }
         .recording-actions button {
             background: none;
             border: none;
             cursor: pointer;
             padding: 6px; /* Easier tap */
             color: #aaa;
             transition: color 0.2s ease;
         }
          .recording-actions button.delete:hover {
             color: red;
         }
          .recording-actions button svg {
              width: 18px;
              height: 18px;
              display: block; /* Prevents extra space */
          }

         /* Playback Modal Styles */
          #playbackModal .modal-content {
              max-width: 95%;
              width: auto; /* Allow shrinking */
              max-height: 90vh; /* Limit height */
              height: auto; /* Adjust height based on content */
              padding: 10px;
              background-color: black;
              display: flex; /* Use flex for layout */
              flex-direction: column;
          }
           #playbackModal .modal-header {
              border-bottom: none; /* Remove border */
              padding-bottom: 5px;
               flex-shrink: 0;
               min-height: 30px; /* Ensure header has some height */
           }
            #playbackModal #playbackTitle {
               color: white;
               font-size: clamp(16px, 4vw, 18px);
               overflow: hidden;
               text-overflow: ellipsis;
               white-space: nowrap;
               flex-grow: 1; /* Take available space */
               margin-right: 10px; /* Space before close button */
            }
             #playbackModal .modal-close svg { stroke: white; }

            #playbackFeed {
                 flex-grow: 1; /* Take remaining vertical space */
                 position: relative;
                 border-radius: 8px; /* Rounded corners for video area */
                 overflow: hidden;
                 background-color: #111;
                 margin-bottom: 15px; /* Space before controls */
                 min-height: 200px; /* Ensure video area isn't too small */
             }
              #playbackFeed video {
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  object-fit: contain; /* Fit video within bounds */
                  display: block;
              }
            /* Playback controls */
            .playback-controls-container { /* Wrapper for both control groups */
                 display: flex;
                 flex-direction: column;
                 gap: 10px; /* Space between speed and main controls */
                 flex-shrink: 0;
             }
            .playback-controls {
                display: flex;
                justify-content: center;
                padding-top: 0; /* Removed extra top padding */
                gap: 20px;
                flex-shrink: 0; /* Prevent shrinking */
            }
            .playback-speed-controls {
                 display: flex;
                 justify-content: center;
                 gap: 10px;
                 flex-shrink: 0;
             }
             .playback-speed-controls button,
             .playback-controls button { /* Style like modal buttons */
                background-color: #444; /* Darker grey */
                color: white;
                border: none;
                border-radius: 9999px;
                padding: clamp(8px, 2.5vw, 10px) clamp(16px, 4vw, 20px);
                font-family: 'Exo 2', sans-serif; /* Use Exo for consistency */
                font-size: clamp(12px, 2.8vw, 13px); /* Slightly smaller */
                cursor: pointer;
                transition: background-color 0.2s, transform 0.2s, border 0.2s;
                 width: auto; /* Allow natural width */
                 min-width: 50px; /* Ensure readable text */
                 text-align: center;
                 border: 2px solid transparent;
            }
             .playback-speed-controls button:hover,
             .playback-controls button:hover {
                 background-color: #555;
                 transform: scale(1.05);
             }
              .playback-speed-controls button:active,
              .playback-controls button:active {
                  transform: scale(0.95);
              }
              /* Style for active speed button */
              .playback-speed-controls button.active-speed {
                  background-color: #666;
                  border-color: #eee;
                  transform: scale(1.02);
              }

             .playback-controls button#deletePlaybackBtn { background-color: #d32f2f; }
             .playback-controls button#deletePlaybackBtn:hover { background-color: #b71c1c; }


        /* Media queries for larger screens */
        @media (min-width: 600px) {
             .app {
                 max-width: 95%; /* Allow app container to be wider */
                 /* Removed explicit max-width like 480px */
                 height: 85vh; /* Limit height */
                 min-height: 600px;
                 max-height: 800px;
                 border-radius: 25px;
                 box-shadow: 0 15px 40px rgba(0,0,0,0.3);
             }
             /* Optional: Increase base font size slightly */
             /* body { font-size: 16px; } */

             /* Responsive Modal Adjustments */
             .modal-content {
                 max-width: 550px; /* Increased max-width for wider screens */
             }
             .confirmation-modal .modal-content {
                 max-width: 400px; /* Slightly larger confirmation */
             }
             /* Settings modal inherits the general .modal-content increase */
             /* Playback modal is already responsive with max-width: 95% */
             /* Stack modal buttons side-by-side on larger screens */
             .modal-footer {
                  flex-direction: row;
                  justify-content: flex-end; /* Align buttons right */
             }
             .modal-footer button {
                 width: auto; /* Allow natural width */
                 min-width: 120px;
             }
             .confirmation-modal .modal-footer {
                 justify-content: center; /* Center confirm buttons */
             }
        }

        /* --- Add this block for responsive grid --- */
        @media (min-width: 600px) {
            .camera-list {
                display: grid;
                /* Auto-fit columns with a minimum width, filling the container */
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: clamp(12px, 3vw, 20px); /* Adjust gap as needed */
                padding-left: clamp(10px, 3vw, 15px); /* Adjust padding */
                padding-right: clamp(10px, 3vw, 15px);
            }

            /* Adjust camera item margins within the grid */
            .camera-item {
                margin-bottom: 0; /* Remove bottom margin used in list view */
            }

             /* Ensure empty state text is centered within the grid container */
             .camera-list.empty-state .empty-state-text,
             #recordingsList.empty-state .empty-state-text {
                 /* Position across the full grid width */
                 grid-column: 1 / -1;
                 position: relative; /* Override absolute positioning */
                 top: auto; left: auto; transform: none; /* Reset positioning */
                 margin-top: 5vh; /* Add some top margin */
             }
        }
        /* --- End responsive grid block --- */

    </style>
</head>
<body>
<div class="app">
    <!-- Landing Page -->
    <div id="landingPage" class="page landing-page">
        <div class="security-badge animate-float">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
            d="M20.91 11.12C20.91 16.01 17.36 20.59 12.51 21.93C12.18 22.02 11.82 22.02 11.49 21.93C6.64 20.59 3.09 16.01 3.09 11.12V6.73C3.09 5.91 3.71 4.98 4.48 4.67L10.05 2.39C11.3 1.88 12.71 1.88 13.96 2.39L19.53 4.67C20.29 4.98 20.92 5.91 20.92 6.73V11.12H20.91Z"
            stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
        </div>
        <div class="landing-content">
            <div class="camera-image"></div>
            <div>
            <h1 class="landing-title">SECURE<br>YOUR<br>W🌍RLD</h1>
            <p class="landing-subtitle">Security CAM App</p>
            </div>
        </div>
        <button class="get-started-btn" aria-label="Get Started">
            Get Started
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M14.4301 5.92993L20.5001 11.9999L14.4301 18.0699" stroke="currentColor"
            stroke-width="1.5" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round" />
            <path d="M3.5 12H20.33" stroke="currentColor" stroke-width="1.5" stroke-miterlimit="10"
            stroke-linecap="round" stroke-linejoin="round" />
            </svg>
        </button>
    </div>

    <!-- Home Page -->
    <div id="homePage" class="page home-page" style="transform: translateX(100%);">
        <div class="home-header">
            <div class="cams-connected">
                <div class="cameras-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 7H17L15 4H9L7 7H3V19H21V7Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="12" cy="13" r="4" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
                <span class="cams-connected-text" id="connectedCamsCount">0 Cams Connected</span>
            </div>
            <div class="header-actions">
                 <button class="add-cam-btn" id="recordingsBtn" aria-label="View Recordings" title="View Recordings">
                   <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g stroke="#FF0000" stroke-width="2">
                        <path d="M12 15C15.3137 15 18 12.3137 18 9C18 5.68629 15.3137 3 12 3C8.68629 3 6 5.68629 6 9C6 12.3137 8.68629 15 12 15Z" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M21 21L16.5 16.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M12 15V21" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M9 21H15" stroke-linecap="round" stroke-linejoin="round"/>
                    </g>
                    </svg>
                 </button>
                <button class="add-cam-btn" id="addCamBtn" aria-label="Add New Camera" title="Add New Camera">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M6 12H18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                        <path d="M12 18V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </button>
            </div>
        </div>
        <div class="search-container">
            <input type="search" id="cameraSearchInput" placeholder="Search cameras..." aria-label="Search Cameras">
        </div>
        <div class="tabs" id="cameraTabs">
            <button class="tab active" data-tab="all" aria-label="All Cameras">All</button>
        </div>
        <div class="camera-list" id="cameraList">
             <p class="empty-state-text">No cameras added yet. Tap the '+' icon to add one.</p>
             <!-- Camera items will be injected here -->
        </div>
    </div>

    <!-- Camera Page -->
    <div id="cameraPage" class="page camera-page" style="transform: translateX(100%);">
        <div class="camera-feed" aria-live="polite">
             <div class="live-indicator" id="liveIndicator">● Live</div>
            <!-- Video/Image Wrapper injected here -->
        </div>
        <div class="camera-header">
            <button class="back-btn" aria-label="Back to Camera List">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15.5 19L8.5 12L15.5 5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
            </button>
            <!-- Wrapper for Timer and Protocol Selector -->
            <div class="header-timer-protocol">
                <div class="timer" id="cameraTimer" aria-label="Camera Timer">00:00:00</div>
                <div class="protocol-selector">
                    <select id="protocolSelector">
                        <option value="auto">Auto</option>
                        <option value="hls">HLS</option>
                        <option value="rtsp">RTSP</option>
                        <option value="webrtc">WebRTC</option>
                        <option value="mjpeg">MJPEG</option>
                        <option value="http">HTTP</option>
                    </select>
                </div>
            </div>
            <!-- End Wrapper -->
        </div>

        <!-- Camera Controls -->
        <div class="controls-container">
            <button class="side-button mute-btn" data-action="mute" aria-label="Mute Camera">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line id="muteLine" x1="2" y1="2" x2="22" y2="22" style="display:none;"></line> <!-- Mute indicator -->
                </svg>
            </button>
            <div class="d-pad" role="group" aria-label="Camera controls">
                <button class="d-pad-button up" data-action="zoom-in" aria-label="Zoom in"></button>
                <button class="d-pad-button right" data-action="pan-right" aria-label="Pan right"></button>
                <button class="d-pad-button down" data-action="zoom-out" aria-label="Zoom out"></button>
                <button class="d-pad-button left" data-action="pan-left" aria-label="Pan left"></button>
                <div class="center" aria-hidden="true"></div>
            </div>
            <button class="side-button camera-btn" data-action="camera-btn" aria-label="Toggle camera">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                    <circle cx="12" cy="13" r="4"></circle>
                </svg>
            </button>
        </div>
        <!-- Stream error overlay -->
        <div class="stream-error-overlay" id="streamErrorOverlay">
            <h3>Stream Connection Error</h3>
            <p id="streamErrorMessage">Unable to connect to camera feed.</p>
            <button id="retryStreamBtn">Retry Connection</button>
            <button class="dismiss" id="dismissStreamErrorBtn">Dismiss</button>
        </div>
    </div>

    <!-- Recordings Page -->
    <div id="recordingsPage" class="page home-page" style="transform: translateX(100%); background-color: #f0f0f0;">
        <div class="home-header">
            <button class="back-btn" id="backFromRecordingsBtn" aria-label="Back to Home Page">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15.5 19L8.5 12L15.5 5" stroke="#555" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
            </button>
            <h2>Recordings</h2>
            <div style="width: clamp(36px, 9vw, 44px); flex-shrink: 0;"></div> <!-- Spacer to balance header -->
             <div class="search-container">
                 <input type="search" id="recordingSearchInput" placeholder="Search recordings..." aria-label="Search Recordings">
             </div>
        </div>
        <div class="camera-list" id="recordingsList"> <!-- Reuse camera-list for scrolling -->
             <p class="empty-state-text">No recordings found.</p>
            <!-- Recordings will be listed here -->
        </div>
    </div>

    <!-- Add Camera Modal -->
    <div id="addCameraModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add Camera</h2>
                <button class="modal-close" id="closeModalBtn" aria-label="Close Modal">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="addCameraForm" class="modal-form">
                    <input type="text" id="cameraName" placeholder="Camera Name" required aria-label="Camera Name" />
                    <input type="text" id="cameraCategory" placeholder="Category (e.g., Living Room)" required aria-label="Camera Category" />
                    <input type="text" id="cameraFeedUrl" placeholder="Camera Feed URL (e.g., .m3u8, .mp4, MJPEG)" required aria-label="Camera Feed URL" />
                    <div class="form-group">
                        <select id="streamProtocol">
                            <option value="auto">Auto-detect</option>
                            <option value="hls">HLS (m3u8)</option>
                            <option value="rtsp">RTSP (Requires Server Proxy)</option>
                            <option value="webrtc">WebRTC (Requires Server)</option>
                            <option value="mjpeg">MJPEG</option>
                            <option value="http">HTTP (mp4/webm)</option>
                        </select>
                        <label for="streamProtocol">Stream Protocol</label>
                    </div>
                </form>
            </div>
             <div class="modal-footer">
                <button type="submit" form="addCameraForm">Add Camera</button>
             </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="confirmation-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Confirm Deletion</h2>
                 <!-- No close button here, force choice -->
            </div>
             <div class="modal-body">
                <p id="confirmationMessage">Are you sure you want to delete this item?</p>
             </div>
             <div class="modal-footer"> <!-- Use modal-footer -->
                <button type="button" id="confirmDeleteBtn">Yes, Delete</button>
                <button type="button" id="cancelDeleteBtn">Cancel</button>
             </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Camera Settings</h2>
                <button class="modal-close" id="closeSettingsModalBtn" aria-label="Close Settings Modal">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="settingsForm" class="modal-form">
                    <input type="text" id="editCameraName" placeholder="Camera Name" required aria-label="Edit Camera Name" />
                    <input type="text" id="editCameraCategory" placeholder="Camera Category" required aria-label="Edit Camera Category" />
                    <input type="text" id="editCameraFeedUrl" placeholder="Camera Feed URL" required aria-label="Edit Camera Feed URL" />
                    <div class="form-group">
                        <select id="editStreamProtocol">
                            <option value="auto">Auto-detect</option>
                            <option value="hls">HLS (m3u8)</option>
                            <option value="rtsp">RTSP (Requires Server Proxy)</option>
                            <option value="webrtc">WebRTC (Requires Server)</option>
                            <option value="mjpeg">MJPEG</option>
                            <option value="http">HTTP (mp4/webm)</option>
                        </select>
                        <label for="editStreamProtocol">Stream Protocol</label>
                    </div>
                    <div class="form-group1">
                        <input type="checkbox" id="editCameraOn" aria-label="Toggle Camera" />
                        <label for="editCameraOn">Camera On</label>
                    </div>
                    <div class="form-group1">
                        <input type="checkbox" id="editMotionDetectionEnabled" aria-label="Enable Motion Detection" />
                        <label for="editMotionDetectionEnabled">Enable Motion Detection (Requires CORS)</label>
                    </div>
                    <input type="number" id="editMotionSensitivity" placeholder="Motion Sensitivity (1=Hi, 100=Lo)" min="1" max="100" aria-label="Motion Sensitivity" />
                </form>
            </div>
             <div class="modal-footer">
                <button type="submit" form="settingsForm">Save Settings</button>
                <button type="button" id="deleteCameraBtn" style="background-color:red;">Delete Camera</button>
            </div>
        </div>
    </div>

    <!-- Category Modal -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="categoryModalTitle">Category Options</h2>
                <button class="modal-close" id="closeCategoryModalBtn" aria-label="Close Modal">
                     <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="categoryForm" class="modal-form">
                    <input type="text" id="newCategoryName" placeholder="New Category Name" aria-label="New Category Name" />
                </form>
            </div>
             <div class="modal-footer">
                <button type="submit" id="renameCategoryBtn" form="categoryForm">Rename Category</button>
                <button type="button" id="deleteCategoryBtn" style="background-color:red;">Delete Category & Cameras</button>
            </div>
        </div>
    </div>

    <!-- Recording Playback Modal -->
    <div id="playbackModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="playbackTitle">Playback</h2>
                <button class="modal-close" id="closePlaybackModalBtn" aria-label="Close Playback">
                     <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                </button>
            </div>
            <div class="camera-feed" id="playbackFeed">
                <video id="playbackVideo" controls controlslist="nodownload noremoteplayback"></video> <!-- Hide default download -->
            </div>
            <div class="playback-controls-container">
                 <div class="playback-speed-controls">
                     <button data-speed="0.5">0.5x</button>
                     <button data-speed="1" class="active-speed">1x</button>
                     <button data-speed="1.5">1.5x</button>
                     <button data-speed="2">2x</button>
                 </div>
                 <div class="playback-controls">
                     <button id="downloadRecordingBtn" aria-label="Download Recording">Download</button>
                     <button id="deletePlaybackBtn" aria-label="Delete Recording">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>
    <!-- Connection Status Indicator -->
    <div id="connectionStatus" class="connection-status">Online</div>
    <!-- Motion Detection Sound -->
    <audio id="motionAlarm" src="alarm.mp3" preload="auto"></audio> <!-- Ensure alarm.mp3 exists -->

</div> <!-- End .app -->
<script>
    // Make sure the DOM is fully loaded before running any JavaScript
    document.addEventListener('DOMContentLoaded', function() {

        // ** State Variables (Global within DOMContentLoaded scope) **
        let currentCameraData = null; // Data of camera being viewed
        let currentEditCameraId = null; // ID of camera being edited/deleted
        let currentCategoryEdit = null; // Category being edited
        let currentOpenRecording = null; // Recording data in playback modal
        let deleteTarget = null; // { type: 'camera'/'category'/'recording', id: ... }
        let timerInterval;
        let timerSeconds = 0;
        let streamRetryCount = 0; // For live view retries
        const maxStreamRetries = 2; // Max retries for live view
        let networkStatus = navigator.onLine;
        let currentStreamProtocol = 'auto'; // Protocol selected on camera page
        let camerasData = { all: [] }; // Main data store {all: [], category1: [], ...}
        let allRecordingsData = []; // Cache for recordings to facilitate search
        let mediaRecorders = {}; // { cameraId: MediaRecorder instance }
        let recordedBlobs = {}; // { cameraId: Blob[] }
        let motionDetectionIntervals = {}; // { cameraId: intervalData {type, id} }
        let previousFrames = {}; // { cameraId: ImageData }
        let hlsInstances = {}; // Store HLS instances { videoElementId: hlsInstance }
        let streamRetryTimeouts = {}; // { videoElementId: timeoutId }

        // Swipe Navigation State (Global for simplicity, reset on touch end)
        let touchStartX = 0;
        let touchEndX = 0;
        let touchStartY = 0; // To check for vertical scroll
        let isSwiping = false;
        const swipeThreshold = 60; // Min pixels to trigger swipe
        const verticalThreshold = 80; // Max vertical pixels allowed during horizontal swipe


        // ** IndexedDB Setup **
        const DB_NAME = 'SecurityCamDB_v2';
        const DB_VERSION = 1;
        const CAMERA_STORE_NAME = 'cameras';
        const RECORDING_STORE_NAME = 'recordings';
        let db = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (db) { resolve(db); return; }

                // console.log("Initializing IndexedDB...");
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    showToast("Database error: Cannot save settings/recordings.", "error");
                    reject("IndexedDB error: " + event.target.error?.message);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Database opened successfully");
                    // Load cameras and recordings from DB *after* successful connection
                    Promise.all([loadCamerasFromDB(), loadAndCacheRecordingsFromDB()])
                           .then(() => resolve(db))
                           .catch(err => {
                                console.error("Failed loading data after DB open", err);
                                // Resolve anyway so app can continue, possibly with empty data
                                resolve(db);
                           });
                };

                request.onupgradeneeded = (event) => {
                    console.log("Upgrading database...");
                    const tempDb = event.target.result;
                    // Camera Store
                    if (!tempDb.objectStoreNames.contains(CAMERA_STORE_NAME)) {
                        tempDb.createObjectStore(CAMERA_STORE_NAME, { keyPath: 'id' });
                        console.log("Cameras object store created");
                    }
                    // Recording Store
                    if (!tempDb.objectStoreNames.contains(RECORDING_STORE_NAME)) {
                        const recStore = tempDb.createObjectStore(RECORDING_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        recStore.createIndex('timestamp', 'timestamp', { unique: false });
                        recStore.createIndex('cameraName', 'cameraName', { unique: false });
                        recStore.createIndex('cameraId', 'cameraId', { unique: false });
                        console.log("Recordings object store created");
                    }
                };
            });
        }

        // ** Data Persistence (IndexedDB for Cameras) **
        async function loadCamerasFromDB() {
            return new Promise(async (resolve, reject) => {
                 if (!db) {
                     console.warn("DB not initialized for loading cameras.");
                     camerasData = { all: [] }; // Start fresh
                     resolve();
                     return;
                 }
                try {
                    const transaction = db.transaction([CAMERA_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CAMERA_STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = (event) => {
                        const allCameras = event.target.result || [];
                        camerasData = { all: allCameras };
                        // Rebuild category arrays
                        allCameras.forEach(cam => {
                             // Ensure default values exist if loading older data
                             cam.panX = cam.panX ?? 0;
                             cam.panY = cam.panY ?? 0;
                             cam.zoom = cam.zoom ?? 1;
                             cam.muted = cam.muted ?? false;
                             cam.motionDetectionEnabled = cam.motionDetectionEnabled ?? false;
                             cam.motionSensitivity = cam.motionSensitivity ?? 30;
                             cam.cameraOn = cam.cameraOn ?? true;
                             cam.protocol = cam.protocol ?? 'auto';
                             cam.type = cam.type ?? ((cam.protocol !== 'mjpeg' && cam.protocol) ? 'video' : 'image'); // Infer type better
                             cam.recording = false; // Ensure recording state is false on load
                             cam.motion = false; // Ensure motion state is false on load

                            if (!camerasData[cam.category]) camerasData[cam.category] = [];
                            camerasData[cam.category].push(cam);
                        });
                        console.log("Cameras loaded from DB:", camerasData.all.length);
                        // Update UI after loading
                        updateTabs();
                        applyCameraSearchFilter(); // Apply search on initial load
                        updateConnectedCamsCount();
                        resolve();
                    };
                    request.onerror = (event) => {
                        console.error("Error loading cameras from DB:", event.target.error);
                        showToast('Failed to load saved cameras.', 'warning');
                        camerasData = { all: [] }; // Start fresh on error
                        reject(event.target.error);
                    };
                } catch (error) {
                     console.error("Error accessing DB for loading cameras:", error);
                     showToast('Error accessing camera storage.', 'error');
                     camerasData = { all: [] };
                     reject(error);
                }
            });
        }

        async function saveCameraToDB(camera) {
             if (!db) return Promise.reject("DB not initialized");
             // Create a copy without volatile state for saving
             const camToSave = { ...camera };
             delete camToSave.motion; // Don't save transient motion state
             // recording state is managed on start/stop explicitly saving
             // delete camToSave.recording; // Keep recording state to remember if it SHOULD be recording on reload (though we stop it now)
             return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([CAMERA_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CAMERA_STORE_NAME);
                    const request = store.put(camToSave); // Use put to add or update
                    request.onsuccess = resolve;
                    request.onerror = (e) => { console.error("DB save error:", e.target.error); reject(e.target.error); };
                } catch (e) { reject(e); }
             });
        }

         async function deleteCameraFromDB(cameraId) {
             if (!db) return Promise.reject("DB not initialized");
              return new Promise((resolve, reject) => {
                 try {
                    const transaction = db.transaction([CAMERA_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CAMERA_STORE_NAME);
                    const request = store.delete(cameraId);
                    request.onsuccess = resolve;
                    request.onerror = (e) => { console.error("DB delete error:", e.target.error); reject(e.target.error); };
                 } catch(e) { reject(e); }
             });
         }

         async function saveAllCamerasToDB() {
             if (!db || !camerasData.all) return Promise.reject("DB not initialized or no camera data");
             // console.log("Saving all cameras to DB...");
             return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([CAMERA_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CAMERA_STORE_NAME);
                    let completed = 0;
                    let total = camerasData.all.length;
                    const errors = [];

                    const checkCompletion = () => {
                        if (completed === total) {
                             if (errors.length > 0) {
                                  console.error("Errors saving some cameras:", errors);
                                  reject(errors);
                             } else {
                                  // console.log("All cameras saved successfully.");
                                  resolve();
                             }
                        }
                    };

                    if (total === 0) {
                         const clearReq = store.clear(); // Ensure store is empty if cameras are empty
                         clearReq.onsuccess = resolve;
                         clearReq.onerror = reject;
                         return;
                    }

                    camerasData.all.forEach(camera => {
                         // Create a copy without volatile state for saving
                         const camToSave = { ...camera };
                         delete camToSave.motion;
                        // delete camToSave.recording; // Keep recording state

                        const request = store.put(camToSave);
                        request.onsuccess = () => {
                            completed++;
                            checkCompletion();
                        };
                        request.onerror = (e) => {
                            console.error(`DB save error for cam ${camera.id}:`, e.target.error);
                            errors.push(e.target.error);
                            completed++;
                            checkCompletion();
                        };
                    });
                } catch(e) { reject(e); }
             });
         }

        // ** Data Service (In-memory manipulation) **
        const dataService = {
            addCamera(camera) {
                // Ensure transient states are initialized
                const newCamera = {...camera, recording: false, motion: false};
                camerasData.all.push(newCamera);
                const category = newCamera.category || 'uncategorized'; // Ensure category exists
                if (!camerasData[category]) camerasData[category] = [];
                camerasData[category].push(newCamera);
                return saveCameraToDB(newCamera); // Async save
            },
            updateCamera(updatedCamData) {
                 return new Promise(async (resolve, reject) => {
                    const index = camerasData.all.findIndex(c => c.id === updatedCamData.id);
                    if (index === -1) return reject("Camera not found for update");

                    const oldCategory = camerasData.all[index].category;
                    const newCategory = updatedCamData.category || 'uncategorized';
                    const oldCamData = camerasData.all[index];

                    // Merge, preserving transient states unless explicitly updated
                    const mergedCamData = {
                        ...oldCamData,
                        ...updatedCamData,
                        // Ensure these aren't accidentally overwritten if not in updatedCamData
                        recording: updatedCamData.recording ?? oldCamData.recording,
                        motion: updatedCamData.motion ?? oldCamData.motion,
                     };

                    // Update in 'all' array
                    camerasData.all[index] = mergedCamData;

                    // Update categories map
                    if (oldCategory !== newCategory) {
                        if (camerasData[oldCategory]) {
                            camerasData[oldCategory] = camerasData[oldCategory].filter(c => c.id !== mergedCamData.id);
                            if (camerasData[oldCategory].length === 0) delete camerasData[oldCategory];
                        }
                        if (!camerasData[newCategory]) camerasData[newCategory] = [];
                        camerasData[newCategory].push(mergedCamData);
                    } else {
                         if (camerasData[newCategory]) {
                             const catIndex = camerasData[newCategory].findIndex(c => c.id === mergedCamData.id);
                             if (catIndex > -1) camerasData[newCategory][catIndex] = mergedCamData;
                             else camerasData[newCategory].push(mergedCamData); // Add if not found
                         } else {
                              camerasData[newCategory] = [mergedCamData]; // Create category if missing
                         }
                    }

                    try {
                         await saveCameraToDB(mergedCamData); // Save updated camera (without transient state)
                         resolve();
                    } catch (error) {
                         reject(error);
                    }
                 });
            },
            deleteCamera(cameraId) {
                 return new Promise(async (resolve, reject) => {
                    const index = camerasData.all.findIndex(c => c.id === cameraId);
                    if (index === -1) return reject("Camera not found for deletion");

                    const category = camerasData.all[index].category;
                    camerasData.all.splice(index, 1); // Remove from 'all'
                    if (camerasData[category]) {
                        camerasData[category] = camerasData[category].filter(c => c.id !== cameraId);
                        if (camerasData[category].length === 0) delete camerasData[category];
                    }
                     try {
                         await deleteCameraFromDB(cameraId); // Delete from DB
                         resolve();
                     } catch (error) {
                         reject(error);
                     }
                 });
            },
            updateCategory(oldCategory, newCategory) {
                return new Promise(async (resolve, reject) => {
                    if (!camerasData[oldCategory] || oldCategory === 'all' || newCategory === 'all' || !newCategory) {
                        return reject("Invalid category rename operation");
                    }
                    // Update category name for all affected cameras in memory
                    camerasData.all = camerasData.all.map(cam => {
                        if (cam.category === oldCategory) {
                            return { ...cam, category: newCategory };
                        }
                        return cam;
                    });
                    // Move cameras in category map
                    camerasData[newCategory] = camerasData[oldCategory];
                    delete camerasData[oldCategory];
                    try {
                         await saveAllCamerasToDB(); // Save all cameras because multiple were updated
                         resolve();
                    } catch(error) {
                         reject(error);
                    }
                });
            },
            deleteCategory(category) {
                return new Promise(async (resolve, reject) => {
                     if (!camerasData[category] || category === 'all') {
                         return reject("Invalid category delete operation");
                     }
                     // Find cameras to delete
                    const camerasToDelete = camerasData.all.filter(cam => cam.category === category);
                    // Remove from memory
                    camerasData.all = camerasData.all.filter(cam => cam.category !== category);
                    delete camerasData[category];
                     // Delete each camera from DB
                     try {
                        const deletePromises = camerasToDelete.map(cam => deleteCameraFromDB(cam.id));
                        await Promise.all(deletePromises);
                        resolve();
                     } catch(error) {
                        reject(error);
                     }
                });
            }
        };


        // ** IndexedDB for Recordings **
        function saveRecordingToDB(recordingData) {
             if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([RECORDING_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(RECORDING_STORE_NAME);
                    const request = store.add(recordingData);
                    request.onsuccess = async (event) => {
                        await loadAndCacheRecordingsFromDB(); // Update cache after saving
                        resolve(event.target.result);
                    };
                    request.onerror = (event) => {
                        console.error("Error saving recording:", event.target.error);
                        showToast("Failed to save recording.", "error");
                        reject("Error saving recording: " + event.target.error?.message);
                    };
                } catch (error) { reject(error); }
            });
        }

        function getRecordingsFromDB() {
             if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                 try {
                    const transaction = db.transaction([RECORDING_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(RECORDING_STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = (event) => { resolve(event.target.result.sort((a, b) => b.timestamp - a.timestamp)); };
                    request.onerror = (event) => { reject("Error fetching recordings: " + event.target.error?.message); };
                } catch (error) { reject(error); }
            });
        }

         // New function to load and cache recordings
         async function loadAndCacheRecordingsFromDB() {
              try {
                 allRecordingsData = await getRecordingsFromDB();
                 // console.log(`Loaded and cached ${allRecordingsData.length} recordings.`);
              } catch (error) {
                 console.error("Error loading/caching recordings:", error);
                 allRecordingsData = []; // Ensure it's an empty array on error
                 showToast("Could not load recordings.", "error");
              }
         }

        function deleteRecordingFromDB(recordingId) {
             if (!db) return Promise.reject("DB not initialized");
             return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([RECORDING_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(RECORDING_STORE_NAME);
                    const request = store.delete(recordingId);
                    request.onsuccess = async () => {
                        await loadAndCacheRecordingsFromDB(); // Update cache after deleting
                        resolve();
                    };
                    request.onerror = (event) => { reject("Error deleting recording: " + event.target.error?.message); };
                } catch (error) { reject(error); }
            });
        }

        // ** UI Update Functions **
        function updateConnectedCamsCount() {
            try {
                const connectedCamsCountEl = document.getElementById('connectedCamsCount');
                if (!connectedCamsCountEl) {
                    console.warn("connectedCamsCount element not found during update.");
                    return;
                }
                const count = camerasData.all?.length || 0;
                connectedCamsCountEl.textContent = `${count} Cam${count !== 1 ? 's' : ''} Connected`;
            } catch (error) { console.error('Error updating cams count:', error); }
        }

        function updateTabs() {
            try {
                const tabsContainer = document.getElementById('cameraTabs');
                 if (!tabsContainer) {
                    console.warn("cameraTabs container not found during update.");
                    return;
                 }
                 const currentActiveTab = tabsContainer.querySelector('.tab.active')?.dataset.tab || 'all';
                tabsContainer.innerHTML = '<button class="tab" data-tab="all" aria-label="All Cameras">All</button>';
                const categories = Object.keys(camerasData).filter(key => key !== 'all');

                categories.sort().forEach(category => {
                     const categoryCount = camerasData[category]?.length || 0;
                     if (categoryCount > 0) {
                          tabsContainer.innerHTML += `<button class="tab" data-tab="${category}" aria-label="${category} Cameras">${category} (${categoryCount})</button>`;
                     } else {
                          // Don't delete here, just don't render - maybe category becomes non-empty later
                     }
                });

                // Re-apply active class
                const newActiveTabElement = tabsContainer.querySelector(`.tab[data-tab="${currentActiveTab}"]`);
                if (newActiveTabElement) {
                     newActiveTabElement.classList.add('active');
                } else {
                    // Fallback to 'All' if the previously active category disappeared
                    const allTab = tabsContainer.querySelector('.tab[data-tab="all"]');
                    if (allTab) allTab.classList.add('active');
                }

                addTabEventListeners(); // Re-attach listeners after modifying innerHTML
            } catch (error) {
                console.error('Error updating tabs:', error);
                showToast('Error updating categories', 'error');
            }
        }

        // --- Helper to destroy HLS instance and cleanup associated data ---
        function cleanupHlsInstance(videoElementId) {
            if (!videoElementId) return; // Safety check

            // Clear associated retry timeout first
            if (streamRetryTimeouts[videoElementId]) {
                clearTimeout(streamRetryTimeouts[videoElementId]);
                delete streamRetryTimeouts[videoElementId];
            }

            // Destroy HLS instance
            if (hlsInstances[videoElementId]) {
                try {
                    hlsInstances[videoElementId].stopLoad();
                    hlsInstances[videoElementId].detachMedia();
                    hlsInstances[videoElementId].destroy();
                    // console.log(`Destroyed HLS for ${videoElementId}`);
                } catch (e) { console.warn(`Error destroying HLS for ${videoElementId}:`, e); }
                delete hlsInstances[videoElementId];
            }
        }

         /**
         * Renders the camera list, optionally using a provided filtered list.
         * @param {string|object[]} categoryOrData - The category name ('all' or specific) OR a pre-filtered array of camera objects.
         */
         function renderCameraList(categoryOrData = 'all') {
             try {
                 const cameraListContainer = document.getElementById('cameraList');
                 if (!cameraListContainer) {
                     console.error("Camera list container not found!");
                     return;
                 }

                 let camerasToRender = [];
                 let categoryName = 'all';

                 if (Array.isArray(categoryOrData)) {
                     camerasToRender = categoryOrData;
                     // Attempt to determine the category if possible (used for empty state message)
                     const currentTab = document.querySelector('#cameraTabs .tab.active')?.dataset.tab;
                     categoryName = currentTab || 'all'; // Use current tab if array is passed (likely from search)
                 } else {
                     categoryName = categoryOrData;
                     camerasToRender = camerasData[categoryName] || (categoryName === 'all' ? camerasData.all : []) || [];
                 }

                 // --- START Cleanup existing elements and resources ---
                 const existingItems = cameraListContainer.querySelectorAll('.camera-item');
                 existingItems.forEach(item => {
                     const videoEl = item.querySelector('video[id^="video-list-"]');
                     if (videoEl) {
                         const camId = videoEl.id.replace('video-list-', '');
                         stopMotionDetection(camId); // Stop motion detection first
                         cleanupHlsInstance(videoEl.id); // Use helper to cleanup HLS & timeouts
                     }
                     // Remove event listeners added dynamically using GSAP if needed
                     if (item._gsapInstance) item._gsapInstance.kill();
                 });
                 // --- END Cleanup ---

                 cameraListContainer.innerHTML = ''; // Clear previous content
                 const isEmpty = camerasToRender.length === 0;
                 cameraListContainer.classList.toggle('empty-state', isEmpty);

                  const searchInput = document.getElementById('cameraSearchInput');
                  const searchTerm = searchInput ? searchInput.value.trim() : '';

                  if (isEmpty) {
                      if (searchTerm) {
                          cameraListContainer.innerHTML = `<p class="empty-state-text">No cameras found matching "${searchTerm}"${categoryName !== 'all' ? ` in "${categoryName}"` : ''}.</p>`;
                      } else if (categoryName === 'all') {
                           cameraListContainer.innerHTML = '<p class="empty-state-text">No cameras added yet.<br>Tap the \'+\' icon to add one.</p>';
                      } else {
                            cameraListContainer.innerHTML = `<p class="empty-state-text">No cameras found in the "${categoryName}" category.</p>`;
                      }
                  }

                 camerasToRender.forEach(camera => {
                     const cameraItem = document.createElement('div');
                     cameraItem.classList.add('camera-item');
                     cameraItem.dataset.cameraId = camera.id;
                     if (camera.motionDetectionEnabled) cameraItem.classList.add('motion-enabled');
                     if (!camera.cameraOn) cameraItem.classList.add('camera-off');

                     const videoWrapper = document.createElement('div');
                     videoWrapper.classList.add('video-wrapper');
                     if (camera.recording) videoWrapper.classList.add('recording-active');

                     // Status Indicator Div
                     const statusDiv = document.createElement('div');
                     statusDiv.classList.add('list-item-status');

                     let mediaElement;
                     let shouldLoadMedia = camera.cameraOn;

                     if (shouldLoadMedia) {
                         cameraItem.classList.add('loading-camera'); // Add loading state initially
                         statusDiv.textContent = 'Connecting...';
                         statusDiv.classList.add('visible', 'status-connecting');

                         if (camera.type === 'video') {
                             mediaElement = document.createElement('video');
                             mediaElement.id = `video-list-${camera.id}`; // Unique ID for list video
                             mediaElement.autoplay = true;
                             mediaElement.muted = true; // Mute list previews
                             mediaElement.loop = true;
                             mediaElement.playsInline = true;
                             mediaElement.crossOrigin = "anonymous";
                             mediaElement.style.transform = `scale(${camera.zoom ?? 1}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY ?? 0}px)`;
                             mediaElement.style.opacity = '0'; // Start hidden, fade in

                             mediaElement.addEventListener('loadeddata', () => {
                                  if(document.body.contains(cameraItem)) {
                                    cameraItem.classList.remove('loading-camera');
                                    mediaElement.style.opacity = '1';
                                    statusDiv.classList.remove('visible', 'status-connecting'); // Remove status on load
                                    if (camera.motionDetectionEnabled) { startMotionDetection(camera, mediaElement); }
                                  }
                             }, { once: true });
                             mediaElement.addEventListener('error', (e) => {
                                  if(document.body.contains(cameraItem)) {
                                    cleanupHlsInstance(mediaElement.id);
                                    handleStreamErrorVisuals(camera, cameraItem, "Stream Error", statusDiv);
                                    stopMotionDetection(camera.id);
                                  }
                             }, { once: true });

                             loadVideoSource(mediaElement, camera); // Pass the element

                         } else if (camera.type === 'image') {
                              mediaElement = document.createElement('img');
                              mediaElement.id = `image-list-${camera.id}`;
                              mediaElement.alt = camera.name;
                              mediaElement.loading = 'lazy';
                              mediaElement.src = camera.feedUrl;
                              mediaElement.style.transform = `scale(${camera.zoom ?? 1}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY ?? 0}px)`;
                              mediaElement.style.opacity = '0';

                              mediaElement.onerror = function() {
                                  if(document.body.contains(cameraItem)) {
                                    handleStreamErrorVisuals(camera, cameraItem, "Image Error", statusDiv);
                                    this.onerror=null;
                                    this.src='placeholder.svg';
                                    this.style.opacity = '1';
                                  }
                              };
                              mediaElement.onload = () => {
                                  if(document.body.contains(cameraItem)) {
                                    cameraItem.classList.remove('loading-camera');
                                    mediaElement.style.opacity = '1';
                                    statusDiv.classList.remove('visible', 'status-connecting');
                                  }
                              };
                         }
                     } else {
                          // Camera is explicitly off
                          videoWrapper.classList.add('camera-off-placeholder');
                          videoWrapper.innerHTML = `<span>Camera Off</span>`;
                          statusDiv.textContent = 'Offline';
                          statusDiv.classList.add('visible', 'status-offline');
                     }

                     if (mediaElement) {
                          videoWrapper.appendChild(mediaElement);
                     }
                     cameraItem.appendChild(videoWrapper);
                     cameraItem.appendChild(statusDiv); // Add status indicator

                     // --- Add Overlay and Info/Actions using template literal ---
                     const infoActionsHTML = `
                         <div class="camera-overlay ${camera.motion ? 'motion-detected-overlay' : ''} ${!camera.cameraOn ? 'camera-off' : ''}">
                             <div class="camera-overlay-text">${camera.motion ? 'Motion Detected' : ''}</div>
                         </div>
                         <div class="camera-info">
                             <span class="camera-name">${camera.name}</span>
                             <div class="camera-actions">
                                 <button class="camera-action-btn record ${camera.recording ? 'recording' : ''}" data-camera-id="${camera.id}" aria-label="${camera.recording ? 'Stop Recording' : 'Start Recording'}" ${camera.type !== 'video' || !camera.cameraOn ? 'disabled style="opacity:0.5; cursor:not-allowed;"' : ''} title="${camera.type !== 'video' ? 'Rec only for video' : (camera.cameraOn ? (camera.recording ? 'Stop Recording' : 'Start Recording') : 'Camera off')}">
                                     <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                         <circle cx="12" cy="12" r="8" stroke="currentColor" stroke-width="1.5" fill="${camera.recording ? 'currentColor' : 'none'}" />
                                     </svg>
                                 </button>
                                 <button class="camera-action-btn motion-detection ${camera.motion ? 'motion-active' : ''}" data-camera-id="${camera.id}" title="${camera.motionDetectionEnabled ? 'Motion Detection Enabled' : 'Motion Detection Disabled'}" aria-label="Motion Detection Status" ${!camera.cameraOn ? 'style="display:none;"' : ''}>
                                      <svg width="20" height="20" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                         <circle cx="24" cy="24" r="10" stroke="${camera.motionDetectionEnabled ? '#00BFFF' : '#777'}" stroke-width="3" fill="none" opacity="${camera.motionDetectionEnabled ? 0.8 : 0.5}" data-original-stroke="${camera.motionDetectionEnabled ? '#00BFFF' : '#777'}" data-original-opacity="${camera.motionDetectionEnabled ? 0.8 : 0.5}"/>
                                         <path d="M24 14C28.4183 14 32 17.5817 32 22C32 26.4183 28.4183 30 24 30C19.5817 30 16 26.4183 16 22C16 17.5817 19.5817 14 24 14Z" stroke="${camera.motionDetectionEnabled ? '#00FFFF' : '#888'}" stroke-width="2" fill="none" data-original-stroke="${camera.motionDetectionEnabled ? '#00FFFF' : '#888'}" data-original-opacity="1"/>
                                         <path d="M10 24C10 15.7157 15.7157 10 24 10C32.2843 10 38 15.7157 38 24C38 32.2843 32.2843 38 24 38C15.7157 38 10 32.2843 10 24Z" stroke="${camera.motionDetectionEnabled ? '#1E90FF' : '#666'}" stroke-width="2" fill="none" opacity="${camera.motionDetectionEnabled ? 0.6 : 0.4}" data-original-stroke="${camera.motionDetectionEnabled ? '#1E90FF' : '#666'}" data-original-opacity="${camera.motionDetectionEnabled ? 0.6 : 0.4}"/>
                                     </svg>
                                 </button>
                             </div>
                         </div>
                     `;
                     cameraItem.insertAdjacentHTML('beforeend', infoActionsHTML);
                     // --- End Template Literal ---

                     // Apply correct motion UI state after HTML is added
                     updateMotionUI(camera.id, camera.motion, camera.motionDetectionEnabled);

                     // Event Listeners for item interaction
                     cameraItem.addEventListener('click', (e) => {
                         if (!e.target.closest('.camera-action-btn')) {
                             openCameraPage(camera);
                         }
                     });
                     cameraItem.addEventListener('contextmenu', (event) => {
                         event.preventDefault();
                         currentEditCameraId = camera.id;
                         openSettingsModal(camera);
                     });

                     let touchTimer;
                     cameraItem.addEventListener('touchstart', (event) => {
                         if (event.touches.length === 1 && !event.target.closest('.camera-action-btn')) {
                             touchTimer = setTimeout(() => {
                                 if(document.body.contains(cameraItem)) { // Check if item still exists
                                    currentEditCameraId = camera.id;
                                    openSettingsModal(camera);
                                    navigator.vibrate && navigator.vibrate(50);
                                 }
                             }, 600);
                         }
                     }, { passive: true });

                     const clearLongPress = () => clearTimeout(touchTimer);
                     cameraItem.addEventListener('touchend', clearLongPress);
                     cameraItem.addEventListener('touchcancel', clearLongPress);
                     cameraItem.addEventListener('touchmove', clearLongPress);

                     cameraListContainer.appendChild(cameraItem);
                 });

                 addAnimationToCameraButtons(); // Apply to newly added buttons
                 addBounceOnHoverCameraItem(); // Apply to newly added items

             } catch (error) {
                 console.error('Error rendering camera list:', error);
                 showToast('Error displaying cameras', 'error');
                 if(document.getElementById('cameraList')) {
                     document.getElementById('cameraList').innerHTML = '<p class="empty-state-text" style="color:red;">Failed to load cameras.</p>';
                 }
             }
         }

        function loadVideoSource(videoElement, camera, retryCount = 0) {
            const MAX_LIST_RETRIES = 2;
            const RETRY_DELAY = 1500; // ms
            const url = camera.feedUrl;
            const protocol = camera.protocol || 'auto';
            const videoId = videoElement.id; // Use ID for tracking

            // Cleanup previous resources associated with this specific video element ID
            cleanupHlsInstance(videoId); // Cleans HLS and retry timeouts
            const currentSrc = videoElement.getAttribute('src');
            if (currentSrc) {
                videoElement.removeAttribute('src');
                try { videoElement.load(); } catch(e){ console.warn(`Error calling video.load() on src clear for ${videoId}:`, e); }
            }
            videoElement._errorHandled = false; // Reset error flag

            try {
                if (((protocol === 'auto' && url.toLowerCase().includes('.m3u8')) || protocol === 'hls') && Hls.isSupported()) {
                    // console.log(`Loading HLS for ${videoId}: ${url}`);
                    const hls = new Hls({
                        // Config for list items (smaller buffers)
                        maxBufferLength: 15, maxMaxBufferLength: 30, enableWorker: true, lowLatencyMode: true,
                        backBufferLength: 30, fragLoadingTimeOut: 10000, manifestLoadingTimeOut: 5000,
                        levelLoadingTimeOut: 5000
                     });
                    hlsInstances[videoId] = hls; // Store instance using video ID

                    hls.loadSource(url);
                    hls.attachMedia(videoElement);
                    hls.on(Hls.Events.ERROR, function(event, data) {
                       // Check if the video element still exists in the DOM before proceeding
                       if (!document.body.contains(videoElement)) {
                           cleanupHlsInstance(videoId); return;
                       }

                        console.error(`List HLS Error for ${videoId}:`, data.type, data.details, data.fatal);
                        if (data.fatal && retryCount < MAX_LIST_RETRIES) {
                             console.log(`Retrying list HLS stream (${retryCount + 1}/${MAX_LIST_RETRIES}) for ${videoId}...`);
                             cleanupHlsInstance(videoId); // Destroy old instance and clear timeout before retry
                             streamRetryTimeouts[videoId] = setTimeout(() => {
                                if (document.body.contains(videoElement)) { // Check element exists again
                                    loadVideoSource(videoElement, camera, retryCount + 1);
                                } else { cleanupHlsInstance(videoId); }
                             }, RETRY_DELAY * (retryCount + 1));
                        } else if (data.fatal) {
                             console.error(`Max list HLS retries reached for ${videoId}.`);
                             if (!videoElement._errorHandled) {
                                 videoElement.dispatchEvent(new Event('error')); // Trigger native error handler
                                 videoElement._errorHandled = true;
                             }
                             cleanupHlsInstance(videoId); // Final cleanup
                        }
                    });
                } else if (protocol === 'rtsp' || protocol === 'webrtc') {
                    console.warn(`${protocol.toUpperCase()} selected for list item ${camera.id}, direct playback not supported.`);
                    videoElement.dispatchEvent(new Event('error'));
                } else {
                    // console.log(`Loading ${protocol} (or native) for ${videoId}: ${url}`);
                    videoElement.src = url;
                    // Native video relies on the 'error' listener added in renderCameraList
                }
            } catch (error) {
                console.error(`Critical error setting video source for ${videoId}:`, error);
                videoElement.dispatchEvent(new Event('error')); // Trigger error handler
            }
        }

         // Modified to accept and update the statusDiv
         function handleStreamErrorVisuals(camera, cameraItem, message, statusDiv = null) {
              if (cameraItem && document.body.contains(cameraItem)) { // Check if item still in DOM
                 cameraItem.classList.remove('loading-camera');
                 const wrapper = cameraItem.querySelector('.video-wrapper');
                 if (wrapper) {
                     wrapper.innerHTML = `<div class="camera-off-placeholder"><span>${message}<br><small>(Check URL/CORS)</small></span></div>`;
                     wrapper.classList.remove('recording-active'); // Ensure recording border is off
                 }
                 const overlay = cameraItem.querySelector('.camera-overlay');
                 if (overlay) overlay.className = 'camera-overlay camera-off'; // Reset overlay state
                 const motionButton = cameraItem.querySelector('.camera-action-btn.motion-detection');
                 if (motionButton) motionButton.style.display = 'none'; // Hide motion button
                 const recordButton = cameraItem.querySelector('.camera-action-btn.record');
                 if (recordButton) { recordButton.style.display = 'none'; recordButton.disabled = true; } // Hide & disable record button

                 // Update status indicator
                 const statusIndicator = statusDiv || cameraItem.querySelector('.list-item-status');
                 if (statusIndicator) {
                      statusIndicator.textContent = 'Error';
                      statusIndicator.className = 'list-item-status visible status-error'; // Ensure correct classes
                 }
              }
              // console.error(`Stream Error for ${camera?.name} (${camera?.id}): ${message}`);
         }


        // ** Camera Page Logic **
         function openCameraPage(cameraData) {
             try {
                 const cameraPageEl = document.getElementById('cameraPage');
                 const homePageEl = document.getElementById('homePage');
                 const cameraFeedContainer = cameraPageEl?.querySelector('.camera-feed');
                 const protocolSelectorEl = document.getElementById('protocolSelector');
                 const streamErrorOverlayEl = document.getElementById('streamErrorOverlay');
                 const cameraTimerDisplayEl = document.getElementById('cameraTimer');
                 const muteLineEl = document.getElementById('muteLine');
                 const liveIndicatorEl = document.getElementById('liveIndicator');

                 if (!cameraPageEl || !homePageEl || !cameraFeedContainer || !protocolSelectorEl || !streamErrorOverlayEl || !cameraTimerDisplayEl || !muteLineEl || !liveIndicatorEl) {
                     console.error("One or more elements missing for openCameraPage");
                     showToast("UI Error: Cannot open camera view.", "error");
                     return;
                 }

                 currentCameraData = cameraData; // Set current camera context
                 cameraFeedContainer.innerHTML = ''; // Clear previous content
                 cameraFeedContainer.className = 'camera-feed loading'; // Reset classes and add loading

                 protocolSelectorEl.value = cameraData.protocol || 'auto';
                 currentStreamProtocol = protocolSelectorEl.value; // Sync selector state
                 streamErrorOverlayEl.classList.remove('active');
                 streamRetryCount = 0; // Reset retry count for live view

                 const wrapper = document.createElement('div');
                 wrapper.classList.add('video-wrapper');
                 // Apply recording glow based on current state
                 if (cameraData.recording) wrapper.classList.add('recording-active');
                 cameraFeedContainer.appendChild(wrapper);

                 cameraTimerDisplayEl.textContent = "00:00:00"; // Reset timer display

                 // Update live indicator text and class
                  liveIndicatorEl.textContent = cameraData.cameraOn ? '● Live' : '■ Off';
                  cameraFeedContainer.classList.toggle('live', cameraData.cameraOn);
                  cameraFeedContainer.classList.toggle('live-off', !cameraData.cameraOn);

                 if (cameraData.cameraOn) {
                      setTimeout(() => {
                           // Check context again before loading stream
                           if (cameraPageEl.style.transform !== 'translateX(0%)' || currentCameraData?.id !== cameraData.id) return;
                           cameraFeedContainer.classList.remove('loading');
                           displayLiveCameraFeed(cameraData, wrapper); // Display the feed
                           startTimer();
                      }, 50); // Short delay for transition smoothness
                 } else {
                      cameraFeedContainer.classList.remove('loading');
                      wrapper.innerHTML = `<div class="camera-off-placeholder"><span>Camera Off</span></div>`;
                      stopTimer();
                 }

                 muteLineEl.style.display = cameraData.muted ? 'block' : 'none'; // Set mute button state

                 // Animate page transition
                 homePageEl.style.transform = 'translateX(-100%)';
                 cameraPageEl.style.transform = 'translateX(0%)';

             } catch (error) {
                 console.error('Error opening camera page:', error);
                 showToast('Error opening camera view', 'error');
                 const errorFeedContainer = document.getElementById('cameraPage')?.querySelector('.camera-feed');
                 if(errorFeedContainer) {
                     errorFeedContainer.innerHTML = '<p style="color:red; padding: 20px; text-align: center;">Failed to load camera view.</p>';
                     errorFeedContainer.classList.remove('loading');
                 }
                 stopTimer();
                 currentCameraData = null; // Clear context on error
             }
         }


         function displayLiveCameraFeed(cameraData, wrapperElement, isRetry = false) {
              try {
                  const cameraPageEl = document.getElementById('cameraPage');
                  const streamErrorOverlayEl = document.getElementById('streamErrorOverlay');
                   if (!cameraPageEl || !streamErrorOverlayEl) {
                       console.error("Missing elements for displayLiveCameraFeed"); return;
                   }
                   // Check if the context is still valid (correct page, correct camera)
                   if (cameraPageEl.style.transform !== 'translateX(0%)' || currentCameraData?.id !== cameraData.id) {
                        console.log("Context changed during displayLiveCameraFeed, aborting.");
                        return;
                   }

                   const videoId = `video-live-${cameraData.id}`; // Define ID for cleanup

                   // Cleanup previous stream resources *before* creating new ones
                   cleanupHlsInstance(videoId); // Clean up HLS specifically using ID
                   const existingImg = wrapperElement.querySelector('img');
                   if(existingImg) existingImg.src = ''; // Clear image source

                   wrapperElement.innerHTML = ''; // Clear previous visual content
                   if(!isRetry) streamErrorOverlayEl.classList.remove('active'); // Only remove error on initial load attempt

                  const protocol = currentStreamProtocol === 'auto' ? (cameraData.protocol || 'auto') : currentStreamProtocol;
                  const url = cameraData.feedUrl;
                  let mediaElement;
                  let cleanupStream = null; // Function to stop/cleanup the specific stream type

                  if (protocol === 'mjpeg') {
                       mediaElement = document.createElement('img');
                       mediaElement.id = `image-live-${cameraData.id}`;
                       mediaElement.alt = "Camera Feed";
                       mediaElement.style.cssText = 'display: block; width: 100%; height: 100%; object-fit: cover;';
                       mediaElement.onerror = () => { if (currentCameraData?.id === cameraData.id) handleLiveStreamError(`Failed to load MJPEG stream. Check URL/CORS.`); }; // Check context in error handler
                       mediaElement.src = url;
                       cleanupStream = () => { if(mediaElement) mediaElement.src = ''; };

                  } else if (protocol === 'rtsp' || protocol === 'webrtc') {
                       console.warn(`${protocol.toUpperCase()} requires server setup.`);
                       handleLiveStreamError(`${protocol.toUpperCase()} streaming requires server setup.`);
                       return;

                  } else { // HLS, HTTP Video, Auto (assuming video)
                       mediaElement = document.createElement('video');
                       mediaElement.id = videoId; // Use consistent ID
                       mediaElement.autoplay = true;
                       mediaElement.controls = false; // Hide default controls
                       mediaElement.muted = cameraData.muted; // Apply current mute state
                       mediaElement.playsInline = true;
                       mediaElement.crossOrigin = "anonymous";
                       mediaElement.style.cssText = 'width: 100%; height: 100%; object-fit: cover; display: block;';
                       mediaElement._errorHandled = false; // Reset error flag for this load attempt

                       mediaElement.addEventListener('playing', () => {
                            // Check context again before acting on 'playing'
                            if (cameraPageEl.style.transform !== 'translateX(0%)' || currentCameraData?.id !== cameraData.id) return;
                            streamErrorOverlayEl.classList.remove('active'); // Hide error on successful play
                            streamRetryCount = 0; // Reset retry count
                            if (cameraData.motionDetectionEnabled) { startMotionDetection(cameraData, mediaElement); }
                       }, { once: true });

                       const videoErrorHandler = (e) => {
                            // Check context and if already handled
                            if (mediaElement._errorHandled || !document.body.contains(mediaElement) || cameraPageEl.style.transform !== 'translateX(0%)' || currentCameraData?.id !== cameraData.id) return;
                            mediaElement._errorHandled = true;
                            console.error(`Live Video Error (Protocol: ${protocol}, ID: ${videoId}):`, e);
                            handleLiveStreamError(`Error loading video stream. Check URL, CORS, or network.`);
                            stopMotionDetection(cameraData.id);
                            cleanupHlsInstance(videoId); // Cleanup HLS on native error too
                       };
                       mediaElement.addEventListener('error', videoErrorHandler);

                       // Load source using HLS.js or native src
                       if (((protocol === 'auto' && url.toLowerCase().includes('.m3u8')) || protocol === 'hls') && Hls.isSupported()) {
                           const hls = new Hls({
                               // Config for Live view (potentially larger buffers)
                               maxBufferLength: 45, // Increased
                               maxMaxBufferLength: 90, // Increased
                               enableWorker: true,
                               lowLatencyMode: true, // Keep low latency if possible
                               backBufferLength: 60,
                               fragLoadingTimeOut: 15000,
                               manifestLoadingTimeOut: 10000,
                               levelLoadingTimeOut: 10000
                               // Consider adding liveSyncDurationCount: 3 (or similar) to stay closer to live edge
                           });
                            hlsInstances[videoId] = hls; // Store for cleanup

                            hls.loadSource(url);
                            hls.attachMedia(mediaElement);
                            hls.on(Hls.Events.ERROR, function(event, data) {
                                // Check context and if already handled
                                if (mediaElement._errorHandled || !document.body.contains(mediaElement) || cameraPageEl.style.transform !== 'translateX(0%)' || currentCameraData?.id !== cameraData.id) {
                                    cleanupHlsInstance(videoId); return;
                                }

                                console.error(`Live HLS Error (${videoId}):`, data.type, data.details, data.fatal);
                                if (data.fatal) {
                                     // Trigger the main error handler which includes retry logic
                                     handleLiveStreamError(`HLS Error: ${data.details}. Check stream URL or network.`);
                                     cleanupHlsInstance(videoId); // Clean up failed instance
                                     mediaElement._errorHandled = true; // Mark as handled
                                }
                                // Non-fatal errors might be recoverable by HLS.js itself
                            });
                            cleanupStream = () => cleanupHlsInstance(videoId); // Use the helper
                       } else {
                            mediaElement.src = url; // Native HLS or HTTP video
                            cleanupStream = () => {
                                if (mediaElement && mediaElement.srcObject instanceof MediaStream) {
                                    mediaElement.srcObject.getTracks().forEach(track => track.stop());
                                    mediaElement.srcObject = null;
                                }
                                if(mediaElement) {
                                    mediaElement.pause();
                                    mediaElement.removeAttribute('src');
                                    try { mediaElement.load(); } catch(e) { console.warn(`Error calling video.load() on native cleanup for ${videoId}:`, e); }
                                }
                                cleanupHlsInstance(videoId); // Also cleanup HLS just in case
                            };
                       }
                  }

                  if (mediaElement) {
                      mediaElement.style.transform = `scale(${cameraData.zoom ?? 1}) translateX(${cameraData.panX ?? 0}px) translateY(${cameraData.panY ?? 0}px)`;
                      wrapperElement.appendChild(mediaElement);
                  }
                  // Store the cleanup function directly on the wrapper for easy access
                  wrapperElement.cleanupStream = cleanupStream;

              } catch (error) {
                  console.error('Critical error displaying live camera feed:', error);
                  handleLiveStreamError('An unexpected error occurred displaying the stream.');
                  stopMotionDetection(cameraData?.id);
                  // Attempt cleanup even on critical error
                  const videoIdOnError = `video-live-${cameraData?.id}`;
                  cleanupHlsInstance(videoIdOnError);
              }
         }

          function handleLiveStreamError(message) {
              const streamErrorOverlayEl = document.getElementById('streamErrorOverlay');
              const streamErrorMessageEl = document.getElementById('streamErrorMessage');
              const cameraFeedContainer = document.getElementById('cameraPage')?.querySelector('.camera-feed');
              const retryButton = document.getElementById('retryStreamBtn');

              // Check if camera page is still active and relevant
              if (!streamErrorOverlayEl || !cameraFeedContainer || document.getElementById('cameraPage')?.style.transform !== 'translateX(0%)' || !currentCameraData) {
                   // console.log("Stream error occurred, but context changed. Ignoring UI update.");
                   return;
              }

              stopTimer();
              stopMotionDetection(currentCameraData.id); // Ensure motion detection is stopped

               const wrapper = cameraFeedContainer.querySelector('.video-wrapper');
               if (wrapper) {
                    // Ensure cleanup happens *before* retrying or showing final error
                    if (wrapper.cleanupStream) { try { wrapper.cleanupStream(); } catch (e) { console.warn("Error during stream cleanup on error:", e); } }
                    wrapper.innerHTML = ''; // Clear the failed feed area
                    wrapper.classList.remove('recording-active'); // Ensure glow is off
               }

               // Attempt Retry Logic
               if (streamRetryCount < maxStreamRetries) {
                    streamRetryCount++;
                    const delay = 1500 * streamRetryCount;
                    const retryMessage = `${message} Retrying (${streamRetryCount}/${maxStreamRetries})...`;
                    if (streamErrorMessageEl) streamErrorMessageEl.textContent = retryMessage;
                    streamErrorOverlayEl.classList.add('active'); // Show overlay during retry
                    if (retryButton) retryButton.style.display = 'none'; // Hide manual retry

                     // Use timeout for retry, store ID for potential cancellation
                     const videoId = `video-live-${currentCameraData.id}`;
                     streamRetryTimeouts[videoId] = setTimeout(() => {
                         delete streamRetryTimeouts[videoId]; // Clear timeout ID before retrying
                          // Check context *again* before retrying
                          if (document.getElementById('cameraPage')?.style.transform === 'translateX(0%)' && currentCameraData) {
                              console.log(`Retrying live stream: Attempt ${streamRetryCount}`);
                               const currentWrapper = document.getElementById('cameraPage')?.querySelector('.camera-feed .video-wrapper');
                               if(currentWrapper) displayLiveCameraFeed(currentCameraData, currentWrapper, true); // isRetry = true
                          } else {
                               console.log("Retry aborted: Page closed or camera changed.");
                               streamErrorOverlayEl?.classList.remove('active'); // Hide overlay if aborted
                          }
                     }, delay);

               } else {
                    // Max retries reached, show final error
                     const finalMessage = `${message} Max retries reached.`;
                     if (streamErrorMessageEl) streamErrorMessageEl.textContent = finalMessage;
                     streamErrorOverlayEl.classList.add('active');
                     if (retryButton) retryButton.style.display = 'block'; // Show manual retry button
               }

               // Ensure live indicator shows error state (or hide it)
               cameraFeedContainer.classList.remove('live', 'live-off');
          }

         function closeCameraPage() {
             const cameraPageEl = document.getElementById('cameraPage');
             const homePageEl = document.getElementById('homePage');
             if (!cameraPageEl || !homePageEl) return; // Safety check

             if (cameraPageEl.style.transform !== 'translateX(0%)') return; // Prevent multiple calls

             try {
                 stopTimer();
                 const closedCameraId = currentCameraData?.id; // Get ID before clearing
                 const wasRecording = currentCameraData?.recording; // Check recording state

                 // Stop processes associated with the camera being closed
                 if (closedCameraId) {
                      stopMotionDetection(closedCameraId);
                       if (mediaRecorders[closedCameraId]) { // Check recorder instance
                            console.log("Stopping recording as camera page is closed.");
                            try { mediaRecorders[closedCameraId].stop(); } catch(e) { console.error("Error stopping recorder on close:", e); }
                            // Let onstop handler manage state and UI update
                       }
                       cleanupHlsInstance(`video-live-${closedCameraId}`); // Cleanup live view HLS
                 }

                 // Clear UI elements
                 const cameraFeedContainer = cameraPageEl.querySelector('.camera-feed');
                 const wrapper = cameraFeedContainer?.querySelector('.video-wrapper');
                 const streamErrorOverlayEl = document.getElementById('streamErrorOverlay');

                 if (wrapper) {
                      // Cleanup stream function might have already been called by cleanupHlsInstance, but call again just in case
                      if (wrapper.cleanupStream) { try { wrapper.cleanupStream(); } catch (e) {console.warn("Cleanup stream error on close:",e);} }
                      wrapper.remove(); // Remove wrapper entirely
                 }

                 if(cameraFeedContainer) cameraFeedContainer.innerHTML = ''; // Clear any remaining content
                 if(cameraFeedContainer) cameraFeedContainer.className = 'camera-feed'; // Reset classes
                 if(streamErrorOverlayEl) streamErrorOverlayEl.classList.remove('active');

                 // Animate page transition
                 homePageEl.style.transform = 'translateX(0%)';
                 cameraPageEl.style.transform = 'translateX(100%)';

                 // Find the camera data *after* potential recording stop, before clearing currentCameraData
                 const previousCamData = camerasData.all.find(c => c.id === closedCameraId);
                 currentCameraData = null; // Clear current camera context

                 // Re-render list if zoom/pan changed OR if recording was stopped on close
                 const needsListRefresh = previousCamData && (previousCamData.zoom !== 1 || previousCamData.panX !== 0 || previousCamData.panY !== 0 || wasRecording); // Check if it *was* recording when closed

                 if (needsListRefresh) {
                       // If recording stopped, ensure the main data reflects this *before* re-rendering
                       if (wasRecording && previousCamData && previousCamData.recording) {
                            // It's possible the onstop handler hasn't updated the state yet.
                            // Force update the in-memory state used by renderCameraList.
                            previousCamData.recording = false;
                       }
                       // Delay rendering slightly to allow state updates from onstop to potentially complete
                       setTimeout(() => {
                           applyCameraSearchFilter(); // Apply search after closing
                       }, 100); // Small delay
                 }

             } catch (error) {
                 console.error('Error closing camera page:', error);
                 // Force back to home on error
                 const homePageForCatch = document.getElementById('homePage');
                 const cameraPageForCatch = document.getElementById('cameraPage');
                 if(homePageForCatch) homePageForCatch.style.transform = 'translateX(0%)';
                 if(cameraPageForCatch) cameraPageForCatch.style.transform = 'translateX(100%)';
                 currentCameraData = null;
             }
         }

        // ** Camera Actions & Controls **
         function performCameraAction(action) {
             try {
                 if (!currentCameraData) { console.error('No camera selected'); return; }
                 const camera = camerasData.all.find(cam => cam.id === currentCameraData.id);
                 if (!camera) { console.error('Camera data inconsistency'); return; }

                 const liveMediaElement = document.getElementById('cameraPage')?.querySelector('.camera-feed video, .camera-feed img');
                 const muteLineEl = document.getElementById('muteLine');
                 let needsSave = false;

                 switch (action) {
                     case 'mute':
                         camera.muted = !camera.muted;
                         if (liveMediaElement?.tagName === 'VIDEO') liveMediaElement.muted = camera.muted;
                         if(muteLineEl) muteLineEl.style.display = camera.muted ? 'block' : 'none';
                         showToast(`Camera ${camera.muted ? 'muted' : 'unmuted'}`, 'info');
                         needsSave = true;
                         break;
                     case 'zoom-in':
                         camera.zoom = Math.min((camera.zoom ?? 1) + 0.1, 3); // Limit zoom
                         if (liveMediaElement) liveMediaElement.style.transform = `scale(${camera.zoom}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY ?? 0}px)`;
                         needsSave = true;
                         break;
                     case 'zoom-out':
                         camera.zoom = Math.max((camera.zoom ?? 1) - 0.1, 0.5); // Limit zoom out
                         if (liveMediaElement) liveMediaElement.style.transform = `scale(${camera.zoom}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY ?? 0}px)`;
                         needsSave = true;
                         break;
                     case 'pan-left':
                         camera.panX = (camera.panX ?? 0) - 10;
                         if (liveMediaElement) liveMediaElement.style.transform = `scale(${camera.zoom ?? 1}) translateX(${camera.panX}px) translateY(${camera.panY ?? 0}px)`;
                         needsSave = true;
                         break;
                     case 'pan-right':
                         camera.panX = (camera.panX ?? 0) + 10;
                         if (liveMediaElement) liveMediaElement.style.transform = `scale(${camera.zoom ?? 1}) translateX(${camera.panX}px) translateY(${camera.panY ?? 0}px)`;
                         needsSave = true;
                         break;
                     // Add Pan Up/Down if needed (currently mapped to zoom)
                     // case 'pan-up': camera.panY = (camera.panY ?? 0) - 10; if (liveMediaElement) liveMediaElement.style.transform = `scale(${camera.zoom ?? 1}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY}px)`; needsSave = true; break;
                     // case 'pan-down': camera.panY = (camera.panY ?? 0) + 10; if (liveMediaElement) liveMediaElement.style.transform = `scale(${camera.zoom ?? 1}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY}px)`; needsSave = true; break;
                     case 'camera-btn':
                         toggleCameraPower(camera.id); // Handles its own save and UI updates
                         break;
                     default: console.warn('Unknown camera action:', action);
                 }

                 // Persist changes like mute, zoom, pan
                 if (needsSave) {
                      dataService.updateCamera(camera).catch(err => showToast('Failed to save camera state.', 'error'));
                 }

             } catch (error) {
                 console.error('Error performing camera action:', error);
                 showToast('Error controlling camera', 'error');
             }
         }

          async function toggleCameraPower(cameraId) {
             const camera = camerasData.all.find(cam => cam.id === cameraId);
             if (!camera) return;

             const wasOn = camera.cameraOn;
             camera.cameraOn = !camera.cameraOn;
             showToast(`Camera ${camera.name} ${camera.cameraOn ? 'turned ON' : 'turned OFF'}`, 'info');

             const cameraPageEl = document.getElementById('cameraPage');
             const liveIndicatorEl = document.getElementById('liveIndicator');

             // Stop processes if turning off
             if (!camera.cameraOn) {
                 stopMotionDetection(cameraId);
                 if (camera.recording && mediaRecorders[cameraId]) {
                     console.log(`Stopping recording for ${camera.name} as it's turned off.`);
                     try { mediaRecorders[cameraId].stop(); } catch(e){ console.error("Error stopping recorder on power off:", e); }
                     // Let onstop handler update state and UI
                 }
                 // Also cleanup HLS if it was playing in the list or live view
                 cleanupHlsInstance(`video-list-${cameraId}`);
                 if (currentCameraData?.id === cameraId) { // Check if it was the current live view
                      cleanupHlsInstance(`video-live-${cameraId}`);
                 }
             }

             // Live View Update (if this camera is currently open)
             if (currentCameraData?.id === cameraId && cameraPageEl?.style.transform === 'translateX(0%)') {
                 const cameraFeedContainer = cameraPageEl.querySelector('.camera-feed');
                 const wrapper = cameraFeedContainer?.querySelector('.video-wrapper');
                 if (!cameraFeedContainer || !liveIndicatorEl || !wrapper) {
                      console.error("Missing elements for live view power toggle update.");
                      return; // Exit if elements are missing
                 }

                 cameraFeedContainer.className = 'camera-feed'; // Reset classes
                 liveIndicatorEl.textContent = camera.cameraOn ? '● Live' : '■ Off';

                 // Cleanup existing stream before changing content
                 if(wrapper.cleanupStream) { try { wrapper.cleanupStream(); } catch(e) {} }
                 wrapper.innerHTML = ''; // Clear previous content

                 if (camera.cameraOn) {
                      cameraFeedContainer.classList.add('live', 'loading');
                      streamRetryCount = 0; // Reset retries for live view
                      setTimeout(() => {
                           // Check context again before loading stream
                           if (cameraPageEl.style.transform !== 'translateX(0%)' || currentCameraData?.id !== cameraId) return;
                           cameraFeedContainer.classList.remove('loading');
                           displayLiveCameraFeed(camera, wrapper); // Load new stream
                           startTimer();
                      }, 50);
                 } else {
                      cameraFeedContainer.classList.add('live-off');
                      wrapper.innerHTML = `<div class="camera-off-placeholder"><span>Camera Off</span></div>`;
                      wrapper.classList.remove('recording-active'); // Ensure glow is off
                      stopTimer();
                      // Motion/Recording already stopped above
                 }
             }

             // List Item Update (Always update the list item regardless of live view state)
             // Use timeout to ensure the list item update doesn't interfere with live view changes if both happen
             setTimeout(() => {
                const listItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
                if (listItem && document.body.contains(listItem)) { // Ensure item still exists
                     listItem.classList.toggle('camera-off', !camera.cameraOn);
                     const listWrapper = listItem.querySelector('.video-wrapper');
                     const statusIndicator = listItem.querySelector('.list-item-status'); // Get status div
                     if (!listWrapper || !statusIndicator) return; // Exit if elements not found

                     const videoId = `video-list-${cameraId}`;
                     // --- Cleanup list item resources before changing content ---
                     // Motion was already stopped if turning off
                     cleanupHlsInstance(videoId); // Cleanup HLS & timeouts
                     listWrapper.innerHTML = ''; // Clear previous content always
                     // --- End Cleanup ---

                     // Disable/enable action buttons and update status div
                     const recordButton = listItem.querySelector('.camera-action-btn.record');
                     const motionButton = listItem.querySelector('.camera-action-btn.motion-detection');

                     if (!camera.cameraOn) {
                          listWrapper.classList.add('camera-off-placeholder');
                          listWrapper.innerHTML = `<span>Camera Off</span>`;
                          listWrapper.classList.remove('recording-active'); // Ensure glow is off
                          listItem.classList.remove('motion-enabled', 'loading-camera'); // Reset states
                          statusIndicator.textContent = 'Offline';
                          statusIndicator.className = 'list-item-status visible status-offline';
                          if (recordButton) { recordButton.disabled = true; recordButton.style.opacity = '0.5'; recordButton.style.cursor = 'not-allowed'; recordButton.title = 'Camera off'; }
                          if (motionButton) { motionButton.style.display = 'none'; }
                     } else {
                          // Re-create the media element and load source
                           listItem.classList.remove('camera-off-placeholder');
                           listItem.classList.add('loading-camera');
                           statusIndicator.textContent ='Connecting...';
                           statusIndicator.className = 'list-item-status visible status-connecting'; // Reset status
                           if (recordButton) { recordButton.disabled = (camera.type !== 'video'); recordButton.style.opacity = (camera.type !== 'video') ? '0.5' : ''; recordButton.style.cursor = (camera.type !== 'video') ? 'not-allowed' : ''; recordButton.title = (camera.type !== 'video') ? 'Rec only for video' : 'Start Recording'; }
                           if (motionButton) { motionButton.style.display = ''; }

                           let newMediaElement;
                           if (camera.type === 'video') {
                               newMediaElement = document.createElement('video');
                               newMediaElement.id = videoId;
                               newMediaElement.autoplay = true; newMediaElement.muted = true; newMediaElement.loop = true; newMediaElement.playsInline = true; newMediaElement.crossOrigin = "anonymous";
                               newMediaElement.style.cssText = `opacity: 0; transform: scale(${camera.zoom ?? 1}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY ?? 0}px);`;
                               newMediaElement.addEventListener('loadeddata', () => { if(document.body.contains(listItem)) { listItem.classList.remove('loading-camera'); newMediaElement.style.opacity = '1'; statusIndicator.classList.remove('visible', 'status-connecting'); if (camera.motionDetectionEnabled) startMotionDetection(camera, newMediaElement); }}, { once: true });
                               newMediaElement.addEventListener('error', () => { if(document.body.contains(listItem)) { cleanupHlsInstance(newMediaElement.id); handleStreamErrorVisuals(camera, listItem, "Stream Error", statusIndicator); }}, { once: true });
                               loadVideoSource(newMediaElement, camera);
                           } else { // Image type
                               newMediaElement = document.createElement('img');
                               newMediaElement.id = `image-list-${camera.id}`;
                               newMediaElement.alt = camera.name; newMediaElement.loading = 'lazy'; newMediaElement.src = camera.feedUrl;
                               newMediaElement.style.cssText = `opacity: 0; transform: scale(${camera.zoom ?? 1}) translateX(${camera.panX ?? 0}px) translateY(${camera.panY ?? 0}px);`;
                               newMediaElement.onerror = function() { if(document.body.contains(listItem)) { handleStreamErrorVisuals(camera, listItem, "Image Error", statusIndicator); this.onerror=null; this.src='placeholder.svg'; this.style.opacity = '1'; }};
                               newMediaElement.onload = () => { if(document.body.contains(listItem)) { listItem.classList.remove('loading-camera'); newMediaElement.style.opacity = '1'; statusIndicator.classList.remove('visible', 'status-connecting'); }};
                           }
                           if(listWrapper && newMediaElement) listWrapper.appendChild(newMediaElement);
                           // Re-apply recording glow if camera was recording (state updated by onstop eventually)
                           if(listWrapper && camera.recording) listWrapper.classList.add('recording-active');
                           listItem.classList.toggle('motion-enabled', camera.motionDetectionEnabled);
                           updateMotionUI(cameraId, camera.motion, camera.motionDetectionEnabled); // Update icon based on actual states
                     }
                }
             }, 50); // Small delay for list item update

             try { await dataService.updateCamera(camera); } // Save the cameraOn state
             catch(err) { showToast('Failed to save camera power state.', 'error'); }
         }


        // ** Recording Logic **
         async function toggleRecording(cameraId) {
             try {
                 const camera = camerasData.all.find(cam => cam.id === cameraId);
                 if (!camera) { showToast('Camera not found.', 'error'); return; }
                 if (camera.type !== 'video') { showToast(`Recording not supported for ${camera.type}.`, 'warning'); return; }
                 if (!camera.cameraOn) { showToast('Cannot record, camera is off.', 'warning'); return; }

                 let currentVideoElement = null;
                 let currentWrapperElement = null;
                 const cameraPageEl = document.getElementById('cameraPage');

                 // Determine the correct video element (live view or list item)
                 if (currentCameraData?.id === cameraId && cameraPageEl?.style.transform === 'translateX(0%)') {
                      currentVideoElement = cameraPageEl.querySelector('.camera-feed video');
                      currentWrapperElement = cameraPageEl.querySelector('.camera-feed .video-wrapper');
                 } else {
                      const listItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
                      currentVideoElement = listItem?.querySelector('video');
                      currentWrapperElement = listItem?.querySelector('.video-wrapper');
                 }

                 // Validate video element and state
                 if (!currentVideoElement || !document.body.contains(currentVideoElement)) {
                      showToast('Video element not found for recording.', 'error'); return;
                 }
                 if(currentWrapperElement?.querySelector('.camera-off-placeholder')) { // Check for placeholder (off or error)
                     const placeholderText = currentWrapperElement.querySelector('.camera-off-placeholder span')?.textContent || '';
                     if(placeholderText.includes('Error')) showToast('Cannot record, stream has an error.', 'warning');
                     else if(placeholderText.includes('Off')) showToast('Cannot record, camera is off.', 'warning');
                     else showToast('Cannot record, stream unavailable.', 'warning');
                     return;
                 }
                 if (currentVideoElement.readyState < 1) { // HAVE_METADATA
                     showToast('Video stream metadata not ready for recording.', 'warning'); return;
                 }
                 if (currentVideoElement.readyState < 3 && !currentVideoElement.captureStream && !currentVideoElement.mozCaptureStream) { // HAVE_FUTURE_DATA (More critical if not using captureStream)
                     console.warn('Video stream might not have enough data, attempting recording anyway...');
                 }

                 // --- Toggle Recording State ---
                 if (camera.recording) {
                     // STOP Recording
                     if (mediaRecorders[cameraId]) {
                         showToast(`Stopping recording for ${camera.name}...`, 'info');
                         // Disable button immediately
                         const recordButtons = document.querySelectorAll(`.camera-action-btn.record[data-camera-id="${cameraId}"]`);
                         recordButtons.forEach(btn => btn.disabled = true);
                         try {
                             mediaRecorders[cameraId].stop(); // onstop handles saving and UI update
                         } catch (e) {
                             console.error("Error calling stop() on MediaRecorder:", e);
                             delete mediaRecorders[cameraId]; delete recordedBlobs[cameraId];
                             camera.recording = false; updateRecordingUI(cameraId, false);
                             await dataService.updateCamera(camera);
                             recordButtons.forEach(btn => btn.disabled = false); // Re-enable on error
                             showToast('Error stopping recording.', 'error');
                         }
                     } else { /* State mismatch handled in onstop now */ console.warn("Recorder state mismatch on stop click."); }
                 } else {
                     // START Recording
                     let stream;
                     try {
                          // --- Stream Capture Logic ---
                          if (currentVideoElement.captureStream) { stream = currentVideoElement.captureStream(); }
                          else if(currentVideoElement.mozCaptureStream) { stream = currentVideoElement.mozCaptureStream(); }
                          else { console.warn("captureStream API not available."); if (currentVideoElement.srcObject instanceof MediaStream) { stream = currentVideoElement.srcObject.clone(); console.log("Cloned srcObject stream for recording."); } else { throw new Error('Cannot capture stream from video element.'); } }
                          // --- Validate Stream ---
                          if (!stream || !stream.active || stream.getVideoTracks().length === 0) { const trackState = stream?.getVideoTracks()[0]?.readyState; throw new Error(`Could not get active video stream (Track state: ${trackState})`); }
                          if (stream.getVideoTracks()[0].muted) { console.warn("Recording source video track is muted."); }
                     } catch (e) { /* Error handling remains the same */ console.error(`Stream capture failed: ${e.message}`, e); if (e.message.includes('secure context') || e.message.includes('origin') || e.name === 'SecurityError') { showToast(`Cannot record: Stream capture requires secure context (HTTPS) or same origin (check CORS?).`, 'error'); } else { showToast(`Cannot record: Stream access denied or invalid.`, 'error'); } return; }

                     // --- MediaRecorder Setup ---
                     // Prioritize WebM with VP9 or VP8, as H.264 support is less common for encoding
                     const mimeTypes = [
                         'video/webm;codecs=vp9,opus',
                         'video/webm;codecs=vp8,opus',
                         'video/webm;codecs=vp9', // Video only might work if opus fails
                         'video/webm;codecs=vp8',
                         'video/webm', // Generic webm
                         // H.264 last resort - less likely to be supported for encoding
                         'video/mp4;codecs=h264,aac',
                         'video/mp4;codecs=h264'
                        ];
                     const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));
                     if (!supportedMimeType) { showToast('No suitable video recording format supported by this browser.', 'error'); return; }
                     console.log(`Recording: Using mimeType: ${supportedMimeType}`); // Log the chosen type
                     const options = { mimeType: supportedMimeType };

                     try {
                         recordedBlobs[cameraId] = []; // Initialize blob array
                         const recorder = new MediaRecorder(stream, options);
                         mediaRecorders[cameraId] = recorder; // Store instance
                         recorder._startTime = Date.now(); // Store start time

                         // --- Event Handlers for Recorder ---
                         recorder.ondataavailable = (event) => { if (event.data?.size > 0) { recordedBlobs[cameraId]?.push(event.data); } };

                         recorder.onstop = async () => {
                              const stopTime = Date.now();
                              const startTime = recorder._startTime ?? stopTime;
                              const duration = (stopTime - startTime) / 1000;
                              const blobsToSave = recordedBlobs[cameraId];
                              const recorderCamId = cameraId; // Capture ID

                              // Cleanup recorder state immediately
                              delete recordedBlobs[recorderCamId];
                              delete mediaRecorders[recorderCamId];

                              // --- Save Recording ---
                              if (blobsToSave?.length > 0) {
                                   const completeBlob = new Blob(blobsToSave, { type: supportedMimeType });
                                   console.log(`Recording saved (${recorderCamId}): Size=${(completeBlob.size / 1024 / 1024).toFixed(2)}MB, Duration=${duration.toFixed(1)}s, Type=${supportedMimeType}`);
                                   const finalCamData = camerasData.all.find(c => c.id === recorderCamId);
                                   const safeCamName = (finalCamData?.name || 'camera').replace(/[^a-z0-9]/gi, '_').toLowerCase();
                                   const dateString = new Date(startTime).toISOString().slice(0, 19).replace(/[:T]/g, '-');
                                   const fileExtension = supportedMimeType.includes('mp4') ? 'mp4' : 'webm'; // Determine extension
                                   const filename = `${safeCamName}_${dateString}.${fileExtension}`;
                                   const recordingData = { blob: completeBlob, filename, timestamp: startTime, cameraName: finalCamData?.name || 'Unknown', cameraId: recorderCamId, mimeType: supportedMimeType, duration };
                                   try {
                                       await saveRecordingToDB(recordingData);
                                       showToast(`Recording "${filename}" saved.`, 'success');
                                       // Only re-render if recordings page is visible
                                       if (document.getElementById('recordingsPage')?.style.transform === 'translateX(0%)') {
                                           applyRecordingSearchFilter();
                                       }
                                   } catch (dbError) { showToast("Error saving recording to DB.", "error"); }
                              } else {
                                    console.warn(`Recording stopped (${recorderCamId}), but no data blobs were captured.`);
                                    showToast("Recording was empty or failed.", "warning");
                              }

                               // --- Final State Update ---
                               const finalCam = camerasData.all.find(c => c.id === recorderCamId);
                               if (finalCam) {
                                   if (finalCam.recording) { // Only update if state is still true
                                        finalCam.recording = false;
                                        updateRecordingUI(recorderCamId, false);
                                        dataService.updateCamera(finalCam).catch(()=>{});
                                   } else { updateRecordingUI(recorderCamId, false); } // Ensure UI is correct
                               } else { updateRecordingUI(recorderCamId, false); } // Update UI anyway

                               // Re-enable button after processing
                               const finalRecordButtons = document.querySelectorAll(`.camera-action-btn.record[data-camera-id="${recorderCamId}"]`);
                               finalRecordButtons.forEach(btn => btn.disabled = false);

                               // Clean up cloned stream tracks
                               if (stream !== currentVideoElement?.srcObject && !currentVideoElement?.captureStream && !currentVideoElement?.mozCaptureStream) { stream.getTracks().forEach(track => track.stop()); }
                         };

                         recorder.onerror = (event) => { /* Error handling remains the same */ console.error("MediaRecorder Error:", event.error || event); showToast(`Recording Error: ${event.error?.name || 'Unknown error'}`, 'error'); const errCam = camerasData.all.find(c => c.id === cameraId); if (errCam) { errCam.recording = false; updateRecordingUI(cameraId, false); dataService.updateCamera(errCam).catch(()=>{}); } else { updateRecordingUI(cameraId, false); } delete mediaRecorders[cameraId]; delete recordedBlobs[cameraId]; const errorRecordButtons = document.querySelectorAll(`.camera-action-btn.record[data-camera-id="${cameraId}"]`); errorRecordButtons.forEach(btn => btn.disabled = false); if (stream !== currentVideoElement?.srcObject && !currentVideoElement?.captureStream && !currentVideoElement?.mozCaptureStream) { stream.getTracks().forEach(track => track.stop()); } };

                         // --- Start Recording ---
                         recorder.start(5000); // Collect data every 5 seconds (adjust if needed)
                         camera.recording = true;
                         updateRecordingUI(cameraId, true); // Update UI immediately
                         await dataService.updateCamera(camera); // Save state change
                         showToast(`Recording started for ${camera.name}...`, 'info');

                     } catch (recorderError) { /* Error handling remains the same */ console.error("Failed to create MediaRecorder:", recorderError); showToast(`Could not start recording: ${recorderError.message}`, "error"); camera.recording = false; updateRecordingUI(cameraId, false); if (stream !== currentVideoElement?.srcObject && !currentVideoElement?.captureStream && !currentVideoElement?.mozCaptureStream) { stream.getTracks().forEach(track => track.stop()); } return; }
                 } // End START Recording block

             } catch (error) { /* Generic error handling remains the same */ console.error('Error in toggleRecording:', error); showToast('Recording error occurred.', 'error'); const errorCam = camerasData.all.find(cam => cam.id === cameraId); if (errorCam && errorCam.recording) { errorCam.recording = false; updateRecordingUI(cameraId, false); dataService.updateCamera(errorCam).catch(()=>{}); } delete mediaRecorders[cameraId]; delete recordedBlobs[cameraId]; const genericErrorButtons = document.querySelectorAll(`.camera-action-btn.record[data-camera-id="${cameraId}"]`); genericErrorButtons.forEach(btn => btn.disabled = false); }
         }

         function updateRecordingUI(cameraId, isRecording) {
              const recordButtons = document.querySelectorAll(`.camera-action-btn.record[data-camera-id="${cameraId}"]`);
              recordButtons.forEach(button => {
                  button.classList.toggle('recording', isRecording);
                  button.querySelector('svg circle')?.setAttribute('fill', isRecording ? 'currentColor' : 'none');
                  button.setAttribute('aria-label', isRecording ? 'Stop Recording' : 'Start Recording');
                  // Ensure button is not disabled (unless actively stopping, handled in toggleRecording)
                  if (!isRecording && button.disabled && !mediaRecorders[cameraId]) {
                      button.disabled = false;
                  }
              });
               // Target BOTH list item and live view wrappers
               const wrappers = document.querySelectorAll(`.camera-item[data-camera-id="${cameraId}"] .video-wrapper, #cameraPage .camera-feed .video-wrapper`);
               wrappers.forEach(wrapper => {
                    const parentCameraItem = wrapper.closest('.camera-item');
                    const isLiveViewWrapper = wrapper.closest('#cameraPage .camera-feed');

                    // Apply effect only if the wrapper matches the context
                    if ((isLiveViewWrapper && currentCameraData?.id === cameraId) || (parentCameraItem && parentCameraItem.dataset.cameraId === cameraId)) {
                        wrapper.classList.toggle('recording-active', isRecording);
                    }
               });
         }


        // ** Motion Detection Logic **
        function startMotionDetection(camera, videoElement) {
            // --- Initial Checks ---
            if (!camera?.motionDetectionEnabled || !camera.cameraOn || !videoElement || videoElement.tagName !== 'VIDEO') {
                return;
            }
            if (motionDetectionIntervals[camera.id]) {
                return; // Already running or pending retry
            }
            // --- End Checks ---

            // More robust readiness check
            if (videoElement.readyState < 3) { // Needs HAVE_FUTURE_DATA
                 if(videoElement.networkState === videoElement.NETWORK_NO_SOURCE || videoElement.error) {
                      console.warn(`Motion detection: Video source error for ${camera.id}. Cannot start.`);
                      updateMotionUI(camera.id, false, false);
                      return;
                 }
                 if(videoElement.paused && videoElement.readyState >= 1) { // HAVE_METADATA but paused
                     console.warn(`Motion detection: Video for ${camera.id} is paused. Will not start now.`);
                     return;
                 }

                 console.warn(`Motion detection: Video element ${videoElement.id} not ready (readyState ${videoElement.readyState}). Retrying...`);
                const retryTimeout = setTimeout(() => {
                    delete motionDetectionIntervals[camera.id]; // Clear timeout holder
                    const currentElement = document.getElementById(videoElement.id);
                    if (currentElement && document.body.contains(currentElement) && currentElement.tagName === 'VIDEO' && !currentElement.error && currentElement.readyState >= 3 && !currentElement.paused) {
                        startMotionDetection(camera, currentElement);
                    } else {
                         console.warn(`Motion detection retry aborted for ${camera.id}. State: ${currentElement?.readyState}, Paused: ${currentElement?.paused}, Error: ${currentElement?.error}`);
                         updateMotionUI(camera.id, false, false);
                     }
                }, 1000);
                 motionDetectionIntervals[camera.id] = { type: 'timeout', id: retryTimeout };
                return; // Exit function, wait for retry
            }

            // --- If Ready, Proceed ---
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            const sensitivityValue = parseInt(camera.motionSensitivity) || 30;
            const pixelColorThreshold = Math.max(5, 55 - Math.floor(sensitivityValue / 2));
            const pixelAreaThreshold = Math.max(0.001, 0.055 - (sensitivityValue / 2000));

            const checkInterval = 250; // ms
            let isDetectingCooldown = false;
            const cooldownDuration = 3000; // ms
            delete previousFrames[camera.id];

            let rafId;
            let lastCheckTime = 0;

            const animationLoop = (timestamp) => {
                 if (!motionDetectionIntervals[camera.id] || motionDetectionIntervals[camera.id]?.id !== rafId) {
                     cancelAnimationFrame(rafId); return;
                 }
                 rafId = requestAnimationFrame(animationLoop);

                if (timestamp - lastCheckTime < checkInterval) { return; }
                lastCheckTime = timestamp;

                // --- Check Video Element Validity ---
                if (!videoElement || !document.body.contains(videoElement) || videoElement.paused || videoElement.ended || videoElement.readyState < 3 || videoElement.error || videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
                    stopMotionDetection(camera.id); return;
                }

                const scaleFactor = 4;
                const checkWidth = Math.max(1, Math.floor(videoElement.videoWidth / scaleFactor));
                const checkHeight = Math.max(1, Math.floor(videoElement.videoHeight / scaleFactor));
                if (canvas.width !== checkWidth) canvas.width = checkWidth;
                if (canvas.height !== checkHeight) canvas.height = checkHeight;

                try {
                    ctx.drawImage(videoElement, 0, 0, checkWidth, checkHeight);
                    const currentFrameData = ctx.getImageData(0, 0, checkWidth, checkHeight);

                    if (previousFrames[camera.id]) {
                        const diffPixelCount = compareFrames(previousFrames[camera.id], currentFrameData, pixelColorThreshold);
                        const motionPercentage = diffPixelCount / (checkWidth * checkHeight);

                        if (motionPercentage > pixelAreaThreshold && !isDetectingCooldown) {
                            isDetectingCooldown = true;
                            triggerMotionAlert(camera.id);
                            setTimeout(() => { isDetectingCooldown = false; }, cooldownDuration);
                        }
                    }
                    previousFrames[camera.id] = currentFrameData;

                } catch (e) {
                    if (e.name === 'SecurityError') {
                        console.error(`Motion detection CORS error for ${camera.id} (${camera.name}). Disabling feature.`);
                        showToast(`Motion detection disabled for ${camera.name} (CORS Error).`, 'warning', 5000);
                        const camData = camerasData.all.find(c => c.id === camera.id);
                        if (camData) {
                            camData.motionDetectionEnabled = false; camData.motion = false;
                            dataService.updateCamera(camData).catch(err => console.error("Failed to save disabled motion state", err));
                            updateMotionUI(camera.id, false, false);
                            const settingsCheckbox = document.getElementById('editMotionDetectionEnabled');
                            const settingsModalEl = document.getElementById('settingsModal');
                             if (settingsModalEl?.classList.contains('active') && currentEditCameraId === camera.id && settingsCheckbox) {
                                settingsCheckbox.checked = false; settingsCheckbox.disabled = true;
                                const label = settingsCheckbox.nextElementSibling;
                                if(label) label.textContent = 'Enable Motion Detection (Blocked by CORS)';
                            }
                             const listItem = document.querySelector(`.camera-item[data-camera-id="${camera.id}"]`);
                             if(listItem) listItem.classList.remove('motion-enabled');
                        }
                         stopMotionDetection(camera.id); return;
                    } else { console.error(`Motion detection error for ${camera.id}:`, e); stopMotionDetection(camera.id); return; }
                }
            }; // End animationLoop definition
            rafId = requestAnimationFrame(animationLoop);
            motionDetectionIntervals[camera.id] = { type: 'raf', id: rafId };
        }

        function stopMotionDetection(cameraId) {
             if (!cameraId) return;
            const intervalData = motionDetectionIntervals[cameraId];
            if (intervalData) {
                // console.log(`Stopping motion detection for ${cameraId} (Type: ${intervalData.type})`);
                if (intervalData.type === 'raf') cancelAnimationFrame(intervalData.id);
                else if (intervalData.type === 'interval') clearInterval(intervalData.id);
                else if (intervalData.type === 'timeout') clearTimeout(intervalData.id);

                delete motionDetectionIntervals[cameraId];
                delete previousFrames[cameraId];

                const camera = camerasData.all.find(cam => cam.id === cameraId);
                updateMotionUI(cameraId, false, camera?.motionDetectionEnabled ?? false);

                if (camera?.motion) { camera.motion = false; }
            }
        }

        function compareFrames(frame1Data, frame2Data, pixelColorThreshold) {
            let motionPixels = 0;
            const data1 = frame1Data.data; const data2 = frame2Data.data; const len = data1.length;
            for (let i = 0; i < len; i += 4) {
                const diffR = Math.abs(data1[i] - data2[i]);
                const diffG = Math.abs(data1[i + 1] - data2[i + 1]);
                const diffB = Math.abs(data1[i + 2] - data2[i + 2]);
                if (diffR > pixelColorThreshold || diffG > pixelColorThreshold || diffB > pixelColorThreshold) { motionPixels++; }
            } return motionPixels;
        }

        function triggerMotionAlert(cameraId) {
            const camera = camerasData.all.find(cam => cam.id === cameraId);
            if (camera && camera.motionDetectionEnabled && !camera.motion) {
                console.log(`Motion detected on ${camera.name} (${cameraId})!`);
                camera.motion = true;
                updateMotionUI(cameraId, true, true); // Show active motion

                 const motionAlarmEl = document.getElementById('motionAlarm');
                 if (motionAlarmEl) { motionAlarmEl.play().catch(e => { if (e.name !== 'NotAllowedError') { console.warn("Alarm play failed:", e); } }); }
                 else { console.warn("Motion alarm element not found"); }
                navigator.vibrate && navigator.vibrate([100, 50, 100]);

                // START Motion-Triggered Recording (if not already recording)
                if (!camera.recording) {
                     console.log(`Attempting motion-triggered recording for ${camera.name}...`);
                     toggleRecording(cameraId).catch(e => {
                         console.error("Motion-triggered recording failed to start:", e);
                         // Maybe show a specific toast?
                         // showToast(`Motion recording failed for ${camera.name}`, 'warning');
                     });
                }
                // END Motion-Triggered Recording

                setTimeout(() => {
                    const currentCamera = camerasData.all.find(cam => cam.id === cameraId);
                    if (currentCamera?.motion) { // Reset only if still in motion state
                        currentCamera.motion = false;
                        updateMotionUI(cameraId, false, currentCamera.motionDetectionEnabled); // Reset visual
                    }
                }, 5000); // Reset visual state after 5s
            }
        }

        function updateMotionUI(cameraId, isMotionActive, isMotionEnabled) {
             const motionButtons = document.querySelectorAll(`.camera-action-btn.motion-detection[data-camera-id="${cameraId}"]`);
             motionButtons.forEach(button => {
                 const camera = camerasData.all.find(c => c.id === cameraId);
                 button.style.display = (camera && camera.cameraOn) ? '' : 'none'; // Hide if camera is off

                 const svgPaths = button.querySelectorAll('svg circle, svg path');
                 svgPaths.forEach(el => {
                    const originalStroke = el.getAttribute('data-original-stroke') || (isMotionEnabled ? (el.tagName === 'circle' ? '#00BFFF' : '#1E90FF') : '#777');
                    const originalOpacity = el.getAttribute('data-original-opacity') || (isMotionEnabled ? (el.tagName === 'circle' ? '0.8' : '0.6') : '0.5');
                    el.style.stroke = isMotionEnabled ? originalStroke : '#777';
                    el.style.opacity = isMotionEnabled ? originalOpacity : '0.4';
                 });
                 button.setAttribute('title', isMotionEnabled ? 'Motion Detection Enabled' : 'Motion Detection Disabled');
                 button.classList.toggle('motion-active', isMotionActive && isMotionEnabled); // Animation only if active AND enabled
             });

             const listItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
             if (listItem) {
                 const overlay = listItem.querySelector('.camera-overlay');
                 const overlayText = overlay?.querySelector('.camera-overlay-text');
                 if (overlay) {
                     const showOverlay = isMotionActive && isMotionEnabled;
                     overlay.classList.toggle('motion-detected-overlay', showOverlay);
                     if (overlayText) overlayText.textContent = showOverlay ? 'Motion Detected' : '';
                 }
                 listItem.classList.toggle('motion-enabled', isMotionEnabled); // For styling SVG via CSS :not()
             }

              // Timer feedback
              if (isMotionActive && isMotionEnabled && currentCameraData?.id === cameraId && document.getElementById('cameraPage')?.style.transform === 'translateX(0%)') {
                   const timerElement = document.getElementById('cameraTimer');
                   if (timerElement) {
                        timerElement.style.transition = 'background-color 0.2s ease';
                        timerElement.style.backgroundColor = 'rgba(255, 255, 0, 0.6)'; // Yellow highlight
                        setTimeout(() => { if (document.getElementById('cameraTimer') === timerElement) { timerElement.style.backgroundColor = ''; } }, 600);
                   }
              }
         }

        // ** Recordings Page & Playback Logic **
        function openRecordingsPage() {
             const homePageEl = document.getElementById('homePage');
             const recordingsPageEl = document.getElementById('recordingsPage');
             const cameraPageEl = document.getElementById('cameraPage');
             if (!homePageEl || !recordingsPageEl) return;

             const closeAndOpen = () => {
                 const homeTransform = homePageEl.style.transform || 'translateX(100%)';
                 if(homeTransform === 'translateX(0%)') { homePageEl.style.transform = 'translateX(-100%)'; }
                 else if (homeTransform === 'translateX(100%)') { homePageEl.style.transform = 'translateX(-100%)'; }
                 recordingsPageEl.style.transform = 'translateX(0%)';
                 // Load and render recordings (consider search term)
                 applyRecordingSearchFilter(); // Use the search filter function directly
             };
             if (cameraPageEl?.style.transform === 'translateX(0%)') { closeCameraPage(); setTimeout(closeAndOpen, 600); }
             else { closeAndOpen(); }
        }
        function closeRecordingsPage() {
            const homePageEl = document.getElementById('homePage');
            const recordingsPageEl = document.getElementById('recordingsPage');
            const recordingsListContainerEl = document.getElementById('recordingsList');
            if (!homePageEl || !recordingsPageEl) return;
            homePageEl.style.transform = 'translateX(0%)';
            recordingsPageEl.style.transform = 'translateX(100%)';
            if(recordingsListContainerEl) recordingsListContainerEl.innerHTML = ''; // Clear list
        }
        /**
         * Renders the recordings list based on provided data.
         * @param {Array} recordingsToRender - The array of recording objects to display.
         */
        function renderRecordingsList(recordingsToRender = []) {
             const recordingsListContainerEl = document.getElementById('recordingsList');
             const searchInput = document.getElementById('recordingSearchInput');
             const searchTerm = searchInput ? searchInput.value.trim() : '';

             if (!recordingsListContainerEl) { console.error("Recordings list container not found"); return; }
             try {
                 recordingsListContainerEl.innerHTML = ''; // Clear previous content
                 recordingsListContainerEl.classList.toggle('empty-state', recordingsToRender.length === 0);

                 if (recordingsToRender.length === 0) {
                      if (searchTerm) {
                          recordingsListContainerEl.innerHTML = `<p class="empty-state-text">No recordings found matching "${searchTerm}".</p>`;
                      } else {
                          recordingsListContainerEl.innerHTML = '<p class="empty-state-text">No recordings found.</p>';
                      }
                      return;
                 }

                 recordingsToRender.forEach(rec => {
                    const item = document.createElement('div'); item.classList.add('recording-item'); item.dataset.recordingId = rec.id;
                    const dateStr = new Date(rec.timestamp).toLocaleString();
                    const durationStr = rec.duration ? `<span class="rec-duration">Duration: ${formatDuration(rec.duration)}</span>` : '';
                    item.innerHTML = `
                        <div class="recording-info">
                            <span class="rec-name">${rec.filename || `Recording ${rec.id}`}</span>
                            <span class="rec-date">${dateStr}</span>
                            ${durationStr}
                        </div>
                        <div class="recording-actions">
                            <button class="delete" data-id="${rec.id}" aria-label="Delete Recording" title="Delete">
                                <svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0"></path></svg>
                            </button>
                        </div>`;
                    item.addEventListener('click', (e) => { if (!e.target.closest('.delete')) openPlaybackModal(rec); });
                    item.querySelector('.delete').addEventListener('click', (e) => { e.stopPropagation(); openConfirmationModal('recording', rec.id, `Delete "${rec.filename || `Recording ${rec.id}`}"?`); });
                    recordingsListContainerEl.appendChild(item);
                });
             } catch (error) { console.error("Error rendering recordings:", error); recordingsListContainerEl.innerHTML = '<p class="empty-state-text" style="color: red;">Failed to load recordings.</p>'; showToast("Could not load recordings.", "error"); }
         }
         function formatDuration(seconds) { /* ... (same as before) ... */ if (isNaN(seconds) || seconds < 0) return 'N/A'; seconds = Math.round(seconds); const hrs = Math.floor(seconds / 3600); const mins = Math.floor((seconds % 3600) / 60); const secs = seconds % 60; let str = ""; if (hrs > 0) str += `${hrs}:` + String(mins).padStart(2, '0') + ":"; else str += String(mins).padStart(2, '0') + ":"; str += String(secs).padStart(2, '0'); return str; }
         function openPlaybackModal(recordingData) {
              const playbackModalEl = document.getElementById('playbackModal');
              const playbackVideoEl = document.getElementById('playbackVideo');
              const playbackTitleEl = document.getElementById('playbackTitle');
              const speedControlsContainer = playbackModalEl?.querySelector('.playback-speed-controls');

              if (!playbackModalEl || !playbackVideoEl || !playbackTitleEl || !speedControlsContainer) {
                  console.error("Playback modal elements missing"); return;
              }
              if (!recordingData || !recordingData.blob || !(recordingData.blob instanceof Blob)) {
                  showToast("Invalid recording data or blob.", "error"); console.error("Invalid recording data:", recordingData); return;
              }
              currentOpenRecording = recordingData;
              playbackTitleEl.textContent = recordingData.filename || `Recording ${recordingData.id}`;
              if (playbackVideoEl.currentSrc && playbackVideoEl.currentSrc.startsWith('blob:')) {
                  URL.revokeObjectURL(playbackVideoEl.currentSrc);
              }
              try {
                   const objectURL = URL.createObjectURL(recordingData.blob);
                   playbackVideoEl.src = objectURL;
                   playbackVideoEl.load();
                   playbackModalEl.classList.add('active');
                   playbackVideoEl.play().catch(e => console.warn("Playback autoplay prevented:", e));

                   // Reset speed controls
                   playbackVideoEl.playbackRate = 1.0;
                   speedControlsContainer.querySelectorAll('button').forEach(btn => {
                       btn.classList.toggle('active-speed', btn.dataset.speed === '1');
                   });

              } catch (e) { console.error("Error creating object URL or playing video:", e); showToast("Cannot play recording.", "error"); closePlaybackModal(); }
         }
         function closePlaybackModal() { /* ... (same as before) ... */ const playbackModalEl = document.getElementById('playbackModal'); const playbackVideoEl = document.getElementById('playbackVideo'); if (!playbackModalEl || !playbackVideoEl) return; playbackVideoEl.pause(); if (playbackVideoEl.currentSrc && playbackVideoEl.currentSrc.startsWith('blob:')) { URL.revokeObjectURL(playbackVideoEl.currentSrc); } playbackVideoEl.removeAttribute('src'); playbackVideoEl.load(); playbackModalEl.classList.remove('active'); currentOpenRecording = null; }

        // ** Search Functionality **
        function applyCameraSearchFilter() {
             const searchInput = document.getElementById('cameraSearchInput');
             const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';
             const activeTab = document.querySelector('#cameraTabs .tab.active');
             const currentCategory = activeTab ? activeTab.dataset.tab : 'all';

             let camerasToFilter = camerasData[currentCategory] || (currentCategory === 'all' ? camerasData.all : []) || [];

             let filteredCameras = [];
             if (searchTerm) {
                 filteredCameras = camerasToFilter.filter(cam =>
                     cam.name.toLowerCase().includes(searchTerm) ||
                     cam.category.toLowerCase().includes(searchTerm)
                 );
             } else {
                 filteredCameras = camerasToFilter; // No search term, use category filter only
             }

             // Pass the filtered array (or category name if no search) to renderCameraList
             renderCameraList(searchTerm ? filteredCameras : currentCategory);
        }

        function applyRecordingSearchFilter() {
             const searchInput = document.getElementById('recordingSearchInput');
             const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';

             let filteredRecordings = [];
             if (searchTerm) {
                 filteredRecordings = allRecordingsData.filter(rec =>
                     (rec.filename && rec.filename.toLowerCase().includes(searchTerm)) ||
                     (rec.cameraName && rec.cameraName.toLowerCase().includes(searchTerm)) ||
                     (new Date(rec.timestamp).toLocaleString().toLowerCase().includes(searchTerm))
                 );
             } else {
                 filteredRecordings = allRecordingsData; // No search term, show all
             }

             renderRecordingsList(filteredRecordings);
        }

        // ** Timer Functions **
        function updateTimer() { const cameraTimerDisplayEl = document.getElementById('cameraTimer'); if (cameraTimerDisplayEl && document.getElementById('cameraPage')?.style.transform === 'translateX(0%)') { timerSeconds++; cameraTimerDisplayEl.textContent = formatDuration(timerSeconds); } else { stopTimer(); } }
        function startTimer() { stopTimer(); timerSeconds = 0; const cameraTimerDisplayEl = document.getElementById('cameraTimer'); if(cameraTimerDisplayEl) { cameraTimerDisplayEl.textContent = formatDuration(0); timerInterval = setInterval(updateTimer, 1000); } }
        function stopTimer() { if(timerInterval) { clearInterval(timerInterval); timerInterval = null; } }

        // ** Modal Handling **
        function openModal(modalElement) { if(modalElement) modalElement.classList.add('active'); }
        function closeModal(modalElement) { if(modalElement) modalElement.classList.remove('active'); }
        function openConfirmationModal(type, id, message) { const confirmationModalEl = document.getElementById('confirmationModal'); const confirmationMessageEl = document.getElementById('confirmationMessage'); if (!confirmationModalEl || !confirmationMessageEl) return; deleteTarget = { type, id }; confirmationMessageEl.textContent = message || `Are you sure?`; confirmationModalEl.classList.add('active'); document.getElementById('cancelDeleteBtn')?.focus(); }
        function closeConfirmationModal() { const confirmationModalEl = document.getElementById('confirmationModal'); if(confirmationModalEl) confirmationModalEl.classList.remove('active'); deleteTarget = null; }
        function openSettingsModal(camera) { const settingsModalEl = document.getElementById('settingsModal'); if (!settingsModalEl) return; currentEditCameraId = camera.id; document.getElementById('editCameraName').value = camera.name; document.getElementById('editCameraCategory').value = camera.category; document.getElementById('editCameraFeedUrl').value = camera.feedUrl; document.getElementById('editStreamProtocol').value = camera.protocol || 'auto'; document.getElementById('editCameraOn').checked = camera.cameraOn; document.getElementById('editMotionDetectionEnabled').checked = camera.motionDetectionEnabled || false; document.getElementById('editMotionSensitivity').value = camera.motionSensitivity || 30; const motionCheckbox = document.getElementById('editMotionDetectionEnabled'); const motionLabel = motionCheckbox?.nextElementSibling; if(motionCheckbox) motionCheckbox.disabled = false; if(motionLabel) motionLabel.textContent = 'Enable Motion Detection (Requires CORS)'; settingsModalEl.classList.add('active'); document.getElementById('editCameraName')?.focus(); }
        function closeSettingsModal() { const settingsModalEl = document.getElementById('settingsModal'); if(settingsModalEl) settingsModalEl.classList.remove('active'); currentEditCameraId = null; }
        function openCategoryModal(category) { const categoryModalEl = document.getElementById('categoryModal'); const categoryModalTitleEl = document.getElementById('categoryModalTitle'); const newCategoryNameInput = document.getElementById('newCategoryName'); if (!categoryModalEl || !categoryModalTitleEl || !newCategoryNameInput) return; currentCategoryEdit = category; categoryModalTitleEl.textContent = `Options for "${category}"`; newCategoryNameInput.value = category; categoryModalEl.classList.add('active'); newCategoryNameInput.focus(); newCategoryNameInput.select(); }
        function closeCategoryModal() { const categoryModalEl = document.getElementById('categoryModal'); if(categoryModalEl) categoryModalEl.classList.remove('active'); currentCategoryEdit = null; }

        // ** Form Submissions **
        async function handleAddCamera(event) { event.preventDefault(); const addCameraModalEl = document.getElementById('addCameraModal'); const addCameraFormEl = document.getElementById('addCameraForm'); const nameInput = document.getElementById('cameraName'); const categoryInput = document.getElementById('cameraCategory'); const feedUrlInput = document.getElementById('cameraFeedUrl'); const protocolSelect = document.getElementById('streamProtocol'); const submitButton = addCameraModalEl?.querySelector('.modal-footer button[type="submit"]'); if (!nameInput || !categoryInput || !feedUrlInput || !protocolSelect || !submitButton) { showToast('Form elements missing.', 'error'); return; } const name = nameInput.value.trim(); const category = categoryInput.value.trim().toLowerCase() || 'uncategorized'; const feedUrl = feedUrlInput.value.trim(); const protocol = protocolSelect.value; if (!name || !feedUrl || !protocol) { showToast('Name, URL and Protocol required.', 'error'); return; } try { new URL(feedUrl); } catch (_) { showToast('Invalid Camera Feed URL.', 'error'); return; } const isVideo = (protocol !== 'mjpeg'); const newCamera = { id: `cam_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`, name, category, feedUrl, protocol, cameraOn: true, muted: false, panX: 0, panY: 0, zoom: 1, type: isVideo ? 'video' : 'image', motionDetectionEnabled: false, motionSensitivity: 30, lastUpdated: new Date().toISOString() }; submitButton.disabled = true; submitButton.textContent = 'Adding...'; try { await dataService.addCamera(newCamera); showToast(`Camera "${name}" added!`, 'success'); if(addCameraModalEl) closeModal(addCameraModalEl); if(addCameraFormEl) addCameraFormEl.reset(); if(protocolSelect) protocolSelect.value = 'auto'; updateTabs(); applyCameraSearchFilter(); updateConnectedCamsCount(); } catch (error) { console.error("Error adding camera:", error); showToast('Failed to save camera.', 'error'); } finally { submitButton.disabled = false; submitButton.textContent = 'Add Camera'; } }
        async function handleSettingsSubmit(event) { event.preventDefault(); const settingsModalEl = document.getElementById('settingsModal'); const settingsFormEl = document.getElementById('settingsForm'); const submitButton = settingsModalEl?.querySelector('.modal-footer button[type="submit"]'); if (!currentEditCameraId || !submitButton) return; const camera = camerasData.all.find(cam => cam.id === currentEditCameraId); if (!camera) { showToast('Error: Camera not found.', 'error'); return; } const editedName = document.getElementById('editCameraName')?.value.trim(); const editedCategory = document.getElementById('editCameraCategory')?.value.trim().toLowerCase() || 'uncategorized'; const editedFeedUrl = document.getElementById('editCameraFeedUrl')?.value.trim(); const editedProtocol = document.getElementById('editStreamProtocol')?.value; const editedCameraOn = document.getElementById('editCameraOn')?.checked; const editedMotionEnabled = document.getElementById('editMotionDetectionEnabled')?.checked; const editedSensitivity = parseInt(document.getElementById('editMotionSensitivity')?.value) || 30; if (!editedName || !editedFeedUrl || typeof editedCameraOn === 'undefined' || typeof editedMotionEnabled === 'undefined') { showToast('Required fields missing or invalid.', 'error'); return; } try { new URL(editedFeedUrl); } catch (_) { showToast('Invalid Camera Feed URL.', 'error'); return; } const oldMotionEnabled = camera.motionDetectionEnabled; const oldCameraOn = camera.cameraOn; const oldFeedUrl = camera.feedUrl; const oldProtocol = camera.protocol; const isVideoType = (editedProtocol !== 'mjpeg'); const settingsChanged = camera.feedUrl !== editedFeedUrl || camera.motionSensitivity !== editedSensitivity || camera.cameraOn !== editedCameraOn || camera.protocol !== editedProtocol || camera.motionDetectionEnabled !== editedMotionEnabled || camera.name !== editedName || camera.category !== editedCategory; if (!settingsChanged) { showToast('No changes detected.', 'info'); closeSettingsModal(); return; } submitButton.disabled = true; submitButton.textContent = 'Saving...'; const updatedCamData = { ...camera, name: editedName, category: editedCategory, feedUrl: editedFeedUrl, protocol: editedProtocol, cameraOn: editedCameraOn, type: isVideoType ? 'video' : 'image', lastUpdated: new Date().toISOString(), motionDetectionEnabled: editedMotionEnabled, motionSensitivity: editedSensitivity }; const needsMotionRestart = updatedCamData.motionDetectionEnabled && updatedCamData.cameraOn && isVideoType && (!oldMotionEnabled || editedCameraOn !== oldCameraOn || settingsChanged); const needsMotionStop = motionDetectionIntervals[camera.id] && (!updatedCamData.motionDetectionEnabled || !updatedCamData.cameraOn || !isVideoType || (settingsChanged && updatedCamData.motionDetectionEnabled)); if (needsMotionStop) { stopMotionDetection(camera.id); } try { await dataService.updateCamera(updatedCamData); showToast('Settings updated.', 'success'); if(settingsModalEl) closeSettingsModal(); const categoryChanged = camera.category !== editedCategory; if (categoryChanged) updateTabs(); applyCameraSearchFilter(); if (needsMotionRestart) { setTimeout(() => { const updatedListItemVideo = document.querySelector(`#video-list-${currentEditCameraId}`); if (updatedListItemVideo && document.body.contains(updatedListItemVideo) && !updatedListItemVideo.error && !updatedListItemVideo.paused && updatedListItemVideo.readyState >= 3) { startMotionDetection(updatedCamData, updatedListItemVideo); } else { console.warn(`Couldn't find viable video element ${updatedListItemVideo?.id} to restart motion after settings save.`); } }, 300); } const liveViewOpen = currentCameraData?.id === currentEditCameraId && document.getElementById('cameraPage')?.style.transform === 'translateX(0%)'; const criticalLiveChange = oldFeedUrl !== editedFeedUrl || oldProtocol !== editedProtocol || oldCameraOn !== editedCameraOn; if (liveViewOpen && criticalLiveChange) { closeCameraPage(); showToast('Live view closed due to critical setting change.', 'info'); } } catch (error) { console.error('Error saving settings:', error); showToast('Failed to save settings.', 'error'); } finally { submitButton.disabled = false; submitButton.textContent = 'Save Settings'; } }
        async function handleCategoryFormSubmit(event) { event.preventDefault(); const categoryModalEl = document.getElementById('categoryModal'); const categoryFormEl = document.getElementById('categoryForm'); const submitButton = categoryModalEl?.querySelector('.modal-footer button[type="submit"]'); if (!currentCategoryEdit || !submitButton) return; const newCategoryName = document.getElementById('newCategoryName')?.value.trim().toLowerCase(); if (!newCategoryName) { showToast('Category name required.', 'error'); return; } if (newCategoryName === 'all') { showToast('"all" is reserved.', 'error'); return; } if (camerasData[newCategoryName] && newCategoryName !== currentCategoryEdit) { showToast(`Category "${newCategoryName}" already exists.`, 'error'); return; } if (newCategoryName !== currentCategoryEdit) { submitButton.disabled = true; submitButton.textContent = 'Renaming...'; try { await dataService.updateCategory(currentCategoryEdit, newCategoryName); showToast(`Category renamed to "${newCategoryName}"`, 'success'); if(categoryModalEl) closeCategoryModal(); updateTabs(); document.querySelectorAll('#cameraTabs .tab').forEach(t => t.classList.remove('active')); const allTab = document.querySelector('#cameraTabs .tab[data-tab="all"]'); if(allTab) allTab.classList.add('active'); applyCameraSearchFilter(); } catch (error) { console.error("Error renaming category:", error); showToast('Failed to rename category.', 'error'); } finally { submitButton.disabled = false; submitButton.textContent = 'Rename Category'; } } else { showToast('No changes made.', 'info'); if(categoryModalEl) closeCategoryModal(); } }

        // ** Delete Actions (Confirmation Modal)**
        // Listener attached in initializeApp

        // ** Toast Notifications **
        function showToast(message, type = 'info', duration = 3000) { try { const toastEl = document.getElementById('toast'); if (!toastEl) return; if (toastEl.timeoutId) clearTimeout(toastEl.timeoutId); toastEl.textContent = message; toastEl.className = 'toast'; void toastEl.offsetWidth; toastEl.classList.add('active', type); toastEl.timeoutId = setTimeout(() => { if(toastEl) toastEl.classList.remove('active'); toastEl.timeoutId = null; }, duration); } catch (error) { console.error('Error showing toast:', error); } }

        // ** Network Status **
        function updateNetworkStatus() { const connectionStatusEl = document.getElementById('connectionStatus'); if (!connectionStatusEl) return; const wasOnline = networkStatus; networkStatus = navigator.onLine; if (networkStatus !== wasOnline || !connectionStatusEl.classList.contains('visible')) { connectionStatusEl.textContent = networkStatus ? 'Online' : 'Offline'; connectionStatusEl.className = `connection-status ${networkStatus ? 'online' : 'offline'} visible`; if (connectionStatusEl.hideTimeout) clearTimeout(connectionStatusEl.hideTimeout); if (networkStatus) { if (!wasOnline) { showToast('Network connection restored.', 'success', 2000); connectionStatusEl.hideTimeout = setTimeout(() => connectionStatusEl.classList.remove('visible'), 3000); } else { connectionStatusEl.hideTimeout = setTimeout(() => connectionStatusEl.classList.remove('visible'), 1500); } } else { showToast('Network connection lost.', 'error', 5000); } } }

        // ** Animations & UI Polish **
        function addAnimationToCameraButtons() { if (typeof gsap !== 'undefined') { gsap.utils.toArray('.camera-action-btn, .add-cam-btn, .back-btn, .side-button, .d-pad-button').forEach(button => { if (button._gsapInstance) button._gsapInstance.kill(); const hoverIn = () => gsap.to(button, { scale: 1.1, duration: 0.2, ease: 'power1.out', overwrite: 'auto' }); const hoverOut = () => gsap.to(button, { scale: 1, duration: 0.2, ease: 'power1.in', overwrite: 'auto' }); const pressDown = () => gsap.to(button, { scale: 0.9, duration: 0.1, ease: 'power1.out', overwrite: 'auto' }); const release = () => gsap.to(button, { scale: 1.0, duration: 0.2, ease: 'power1.in', overwrite: 'auto' }); button.addEventListener('mouseenter', hoverIn); button.addEventListener('mouseleave', hoverOut); button.addEventListener('mousedown', pressDown); button.addEventListener('mouseup', release); button.addEventListener('touchstart', pressDown, { passive: true }); button.addEventListener('touchend', release); button.addEventListener('touchcancel', release); button._gsapInstance = { kill: () => { button.removeEventListener('mouseenter', hoverIn); button.removeEventListener('mouseleave', hoverOut); button.removeEventListener('mousedown', pressDown); button.removeEventListener('mouseup', release); button.removeEventListener('touchstart', pressDown); button.removeEventListener('touchend', release); button.removeEventListener('touchcancel', release); gsap.killTweensOf(button); } }; }); } }
        function addBounceOnHoverCameraItem() { if (typeof gsap !== 'undefined') { gsap.utils.toArray('.camera-item').forEach(item => { if(item._gsapInstance) item._gsapInstance.kill(); const hoverIn = () => gsap.to(item, { scale: 1.02, duration: 0.3, ease: 'back.out(1.7)', overwrite: 'auto' }); const hoverOut = () => gsap.to(item, { scale: 1, duration: 0.3, ease: 'back.out(1.7)', overwrite: 'auto' }); item.addEventListener('mouseenter', hoverIn); item.addEventListener('mouseleave', hoverOut); item._gsapInstance = { kill: () => { item.removeEventListener('mouseenter', hoverIn); item.removeEventListener('mouseleave', hoverOut); gsap.killTweensOf(item); } }; }); } }
        function addTabEventListeners() { /* ... (same as before using delegation) ... */ const tabsContainer = document.getElementById('cameraTabs'); if (!tabsContainer) return; if (tabsContainer._tabClickListener) tabsContainer.removeEventListener('click', tabsContainer._tabClickListener); if (tabsContainer._tabContextMenuListener) tabsContainer.removeEventListener('contextmenu', tabsContainer._tabContextMenuListener); if (tabsContainer._tabTouchStartListener) tabsContainer.removeEventListener('touchstart', tabsContainer._tabTouchStartListener); if (tabsContainer._tabTouchEndListener) { tabsContainer.removeEventListener('touchend', tabsContainer._tabTouchEndListener); tabsContainer.removeEventListener('touchcancel', tabsContainer._tabTouchEndListener); tabsContainer.removeEventListener('touchmove', tabsContainer._tabTouchEndListener); } tabsContainer._tabClickListener = (event) => { const tab = event.target.closest('.tab'); if (tab) { clearTimeout(tab._touchTimer); if (!tab.classList.contains('active')) { tabsContainer.querySelectorAll('.tab').forEach(t => t.classList.remove('active')); tab.classList.add('active'); applyCameraSearchFilter(); } } }; tabsContainer.addEventListener('click', tabsContainer._tabClickListener); let touchTimer; tabsContainer._tabTouchStartListener = (event) => { const tab = event.target.closest('.tab'); if (tab && event.touches.length === 1 && tab.dataset.tab !== 'all') { touchTimer = setTimeout(() => { openCategoryModal(tab.dataset.tab); navigator.vibrate && navigator.vibrate(50); }, 600); tab._touchTimer = touchTimer; } }; tabsContainer.addEventListener('touchstart', tabsContainer._tabTouchStartListener, { passive: true }); tabsContainer._tabTouchEndListener = (event) => { const tab = event.target.closest('.tab'); if (tab && tab._touchTimer) { clearTimeout(tab._touchTimer); } }; tabsContainer.addEventListener('touchend', tabsContainer._tabTouchEndListener); tabsContainer.addEventListener('touchcancel', tabsContainer._tabTouchEndListener); tabsContainer.addEventListener('touchmove', tabsContainer._tabTouchEndListener); tabsContainer._tabContextMenuListener = (event) => { const tab = event.target.closest('.tab'); if (tab && tab.dataset.tab !== 'all') { event.preventDefault(); openCategoryModal(tab.dataset.tab); } }; tabsContainer.addEventListener('contextmenu', tabsContainer._tabContextMenuListener); }

        // ** Swipe Navigation Logic **
        function handleTouchStart(event) { const targetElement = event.target; const closestScrollable = targetElement.closest('.camera-list, .tabs, .modal-content, .modal-body'); const closestInteractive = targetElement.closest('button, a, input, select, .d-pad-button, .side-button, video[controls]'); if (closestInteractive) { isSwiping = false; return; } if (closestScrollable) { const canScrollVertically = closestScrollable.scrollHeight > closestScrollable.clientHeight; if (canScrollVertically) { const isAtTop = closestScrollable.scrollTop <= 0; const isAtBottom = Math.abs(closestScrollable.scrollHeight - closestScrollable.clientHeight - closestScrollable.scrollTop) < 1; if (!isAtTop && !isAtBottom) { isSwiping = false; return; } } } const firstTouch = event.touches[0]; touchStartX = firstTouch.clientX; touchStartY = firstTouch.clientY; isSwiping = true; touchEndX = touchStartX; }
        function handleTouchMove(event) { if (!isSwiping) return; touchEndX = event.touches[0].clientX; const deltaX = Math.abs(touchEndX - touchStartX); const deltaY = Math.abs(event.touches[0].clientY - touchStartY); if (deltaY > deltaX + 10 && deltaY > 20) { isSwiping = false; } }
        function handleTouchEnd(event) { if (!isSwiping) { touchStartX = 0; touchEndX = 0; touchStartY = 0; return; } isSwiping = false; const deltaX = touchEndX - touchStartX; const deltaY = Math.abs(event.changedTouches[0].clientY - touchStartY); if (Math.abs(deltaX) > swipeThreshold && deltaY < verticalThreshold) { const cameraPageEl = document.getElementById('cameraPage'); const recordingsPageEl = document.getElementById('recordingsPage'); const swipeTargetPage = event.target.closest('.page'); if (deltaX > 0) { if (swipeTargetPage === cameraPageEl && cameraPageEl.style.transform === 'translateX(0%)') { closeCameraPage(); } else if (swipeTargetPage === recordingsPageEl && recordingsPageEl.style.transform === 'translateX(0%)') { closeRecordingsPage(); } } } touchStartX = 0; touchEndX = 0; touchStartY = 0; }

        // ** Keyboard Navigation **
        function handleKeyboardNavigation(e) { const playbackModalEl = document.getElementById('playbackModal'); const categoryModalEl = document.getElementById('categoryModal'); const settingsModalEl = document.getElementById('settingsModal'); const confirmationModalEl = document.getElementById('confirmationModal'); const addCameraModalEl = document.getElementById('addCameraModal'); const streamErrorOverlayEl = document.getElementById('streamErrorOverlay'); const cameraPageEl = document.getElementById('cameraPage'); const recordingsPageEl = document.getElementById('recordingsPage'); if (e.key === 'Escape') { if (playbackModalEl?.classList.contains('active')) closePlaybackModal(); else if (categoryModalEl?.classList.contains('active')) closeCategoryModal(); else if (settingsModalEl?.classList.contains('active')) closeSettingsModal(); else if (confirmationModalEl?.classList.contains('active')) closeConfirmationModal(); else if (addCameraModalEl?.classList.contains('active')) closeModal(addCameraModalEl); else if (streamErrorOverlayEl?.classList.contains('active')) streamErrorOverlayEl.classList.remove('active'); else if (cameraPageEl?.style.transform === 'translateX(0%)') closeCameraPage(); else if (recordingsPageEl?.style.transform === 'translateX(0%)') closeRecordingsPage(); } if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) { if (confirmationModalEl?.classList.contains('active')) { const confirmBtn = document.getElementById('confirmDeleteBtn'); if(confirmBtn && !confirmBtn.disabled) { e.preventDefault(); confirmBtn.click(); } } else if (addCameraModalEl?.classList.contains('active')) { const submitBtn = addCameraModalEl.querySelector('.modal-footer button[type="submit"]'); if (submitBtn && !submitBtn.disabled) { e.preventDefault(); submitBtn.click(); } } else if (settingsModalEl?.classList.contains('active')) { const submitBtn = settingsModalEl.querySelector('.modal-footer button[type="submit"]'); if (submitBtn && !submitBtn.disabled) { e.preventDefault(); submitBtn.click(); } } else if (categoryModalEl?.classList.contains('active')) { const submitBtn = categoryModalEl.querySelector('.modal-footer button[type="submit"]'); if (submitBtn && !submitBtn.disabled) { e.preventDefault(); submitBtn.click(); } } } }


        // ** Initial Setup **
        async function initializeApp() {
             console.log("Initializing App v2.5.2..."); // Increment version

             // --- Element References ---
             const landingPage = document.getElementById('landingPage');
             const homePage = document.getElementById('homePage');
             const cameraPage = document.getElementById('cameraPage');
             const recordingsPage = document.getElementById('recordingsPage');
             const addCameraModal = document.getElementById('addCameraModal');
             const confirmationModal = document.getElementById('confirmationModal');
             const settingsModal = document.getElementById('settingsModal');
             const categoryModal = document.getElementById('categoryModal');
             const playbackModal = document.getElementById('playbackModal');
             const getStartedBtn = document.querySelector('.get-started-btn');
             const backBtn = cameraPage?.querySelector('.back-btn');
             const backFromRecordingsBtn = document.getElementById('backFromRecordingsBtn');
             const cameraListContainer = document.getElementById('cameraList');
             const addCamBtn = document.getElementById('addCamBtn');
             const recordingsBtn = document.getElementById('recordingsBtn');
             const addCameraForm = document.getElementById('addCameraForm');
             const settingsForm = document.getElementById('settingsForm');
             const categoryForm = document.getElementById('categoryForm');
             const closeModalBtn = document.getElementById('closeModalBtn');
             const closeSettingsModalBtn = document.getElementById('closeSettingsModalBtn');
             const closeCategoryModalBtn = document.getElementById('closeCategoryModalBtn');
             const closePlaybackModalBtn = document.getElementById('closePlaybackModalBtn');
             const deleteCameraBtn = document.getElementById('deleteCameraBtn');
             const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
             const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
             const deleteCategoryBtn = document.getElementById('deleteCategoryBtn');
             const streamErrorOverlay = document.getElementById('streamErrorOverlay');
             const retryStreamBtn = document.getElementById('retryStreamBtn');
             const dismissStreamErrorBtn = document.getElementById('dismissStreamErrorBtn');
             const protocolSelector = document.getElementById('protocolSelector');
             const cameraControls = document.querySelector('.controls-container');
             const downloadRecordingBtn = document.getElementById('downloadRecordingBtn');
             const deletePlaybackBtn = document.getElementById('deletePlaybackBtn');
             const cameraSearchInput = document.getElementById('cameraSearchInput');
             const recordingSearchInput = document.getElementById('recordingSearchInput');
             const playbackSpeedControls = playbackModal?.querySelector('.playback-speed-controls');
             const playbackVideo = document.getElementById('playbackVideo');
             const toast = document.getElementById('toast');
             // --- End Element References ---


             // GSAP Badge Animation
             if (typeof gsap !== 'undefined') { gsap.to('.security-badge', { y: -8, duration: 1.5, repeat: -1, yoyo: true, ease: 'power1.inOut' }); }

             // Setup DB -> Load Cameras/Recordings -> Initial Render
             try { await initDB(); } catch (error) { console.error("DB Initialization or initial data load failed:", error); showToast("Failed to load app data.", "error"); updateTabs(); applyCameraSearchFilter(); updateConnectedCamsCount(); applyRecordingSearchFilter(); }

             // Network Status Listeners
             updateNetworkStatus(); window.addEventListener('online', updateNetworkStatus); window.addEventListener('offline', updateNetworkStatus); setInterval(updateNetworkStatus, 30000);

             // ---- CORE EVENT LISTENERS ---- (Ensure elements exist before adding listeners)
             if (getStartedBtn && landingPage && homePage) { getStartedBtn.addEventListener('click', () => { try { landingPage.style.transform = 'translateX(-100%)'; homePage.style.transform = 'translateX(0%)'; } catch (e) { console.error("Error applying transforms:", e); showToast("UI transition error", "error"); } }); } else { console.error("ERROR: Could not attach Get Started listener!"); if(toast) showToast("Initialization Error: Cannot start app.", "error"); }
             if(backBtn) backBtn.addEventListener('click', closeCameraPage); else console.warn("Back button (camera) not found");
             if(backFromRecordingsBtn) backFromRecordingsBtn.addEventListener('click', closeRecordingsPage); else console.warn("Back button (recordings) not found");
             if(recordingsBtn) recordingsBtn.addEventListener('click', openRecordingsPage); else console.warn("Recordings button not found");
             if(addCamBtn && addCameraModal) addCamBtn.addEventListener('click', () => openModal(addCameraModal)); else console.warn("Add Cam button or modal not found");
             if(closeModalBtn && addCameraModal) closeModalBtn.addEventListener('click', () => closeModal(addCameraModal));
             if(closeSettingsModalBtn && settingsModal) closeSettingsModalBtn.addEventListener('click', closeSettingsModal);
             if(closeCategoryModalBtn && categoryModal) closeCategoryModalBtn.addEventListener('click', closeCategoryModal);
             if(closePlaybackModalBtn && playbackModal) closePlaybackModalBtn.addEventListener('click', closePlaybackModal);
             if(cancelDeleteBtn && confirmationModal) cancelDeleteBtn.addEventListener('click', closeConfirmationModal);
             if (downloadRecordingBtn) downloadRecordingBtn.addEventListener('click', () => { if (currentOpenRecording?.blob) { try { const a = document.createElement('a'); a.href = URL.createObjectURL(currentOpenRecording.blob); a.download = currentOpenRecording.filename || `recording_${currentOpenRecording.id}.webm`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); showToast('Download started.', 'success'); } catch(e) { console.error("Download error:", e); showToast('Download failed.', 'error'); } } else { showToast("No recording loaded.", "error"); } }); else console.warn("Download button not found");
             if (deletePlaybackBtn) deletePlaybackBtn.addEventListener('click', () => { if (currentOpenRecording) { const id = currentOpenRecording.id; const name = currentOpenRecording.filename || `Recording ${id}`; closePlaybackModal(); openConfirmationModal('recording', id, `Delete "${name}"?`); } else { showToast("No recording loaded.", "error"); } }); else console.warn("Delete Playback button not found");
             if(addCameraForm) addCameraForm.addEventListener('submit', handleAddCamera); else console.warn("Add Camera Form not found");
             if(settingsForm) settingsForm.addEventListener('submit', handleSettingsSubmit); else console.warn("Settings Form not found");
             if(categoryForm) categoryForm.addEventListener('submit', handleCategoryFormSubmit); else console.warn("Category Form not found");
             if(deleteCameraBtn) deleteCameraBtn.addEventListener('click', () => { if(currentEditCameraId) { const camName = camerasData.all.find(c=>c.id===currentEditCameraId)?.name; openConfirmationModal('camera', currentEditCameraId, `Delete camera "${camName || 'this camera'}"?`); } }); else console.warn("Delete Camera button not found");
             if(deleteCategoryBtn) deleteCategoryBtn.addEventListener('click', () => { if(currentCategoryEdit) openConfirmationModal('category', currentCategoryEdit, `Delete category "${currentCategoryEdit}" and ALL its cameras? This cannot be undone.`); }); else console.warn("Delete Category button not found");
             if(confirmDeleteBtn) { confirmDeleteBtn.addEventListener('click', async () => { if (!deleteTarget || !confirmDeleteBtn) return; const originalTarget = { ...deleteTarget }; const originalButtonText = confirmDeleteBtn.textContent; confirmDeleteBtn.textContent = 'Deleting...'; confirmDeleteBtn.disabled = true; document.getElementById('cancelDeleteBtn')?.setAttribute('disabled', 'true'); closeConfirmationModal(); showToast(`Deleting ${originalTarget.type}...`, 'info', 1500); try { if (originalTarget.type === 'camera') { stopMotionDetection(originalTarget.id); if(mediaRecorders[originalTarget.id]) { try { mediaRecorders[originalTarget.id].stop(); } catch(e){} delete mediaRecorders[originalTarget.id]; delete recordedBlobs[originalTarget.id]; } cleanupHlsInstance(`video-list-${originalTarget.id}`); await dataService.deleteCamera(originalTarget.id); showToast('Camera deleted.', 'success'); if (currentCameraData?.id === originalTarget.id && document.getElementById('cameraPage')?.style.transform === 'translateX(0%)') { closeCameraPage(); } } else if (originalTarget.type === 'category') { const camerasInCategory = camerasData.all.filter(cam => cam.category === originalTarget.id); camerasInCategory.forEach(cam => { stopMotionDetection(cam.id); if(mediaRecorders[cam.id]) { try{ mediaRecorders[cam.id].stop(); } catch(e){} delete mediaRecorders[cam.id]; delete recordedBlobs[cam.id]; } cleanupHlsInstance(`video-list-${cam.id}`); }); await dataService.deleteCategory(originalTarget.id); showToast(`Category "${originalTarget.id}" deleted.`, 'success'); } else if (originalTarget.type === 'recording') { await deleteRecordingFromDB(originalTarget.id); showToast('Recording deleted.', 'success'); if (document.getElementById('recordingsPage')?.style.transform === 'translateX(0%)') { applyRecordingSearchFilter(); } if(confirmDeleteBtn) { confirmDeleteBtn.textContent = originalButtonText; confirmDeleteBtn.disabled = false; } document.getElementById('cancelDeleteBtn')?.removeAttribute('disabled'); deleteTarget = null; return; } updateTabs(); applyCameraSearchFilter(); updateConnectedCamsCount(); } catch (error) { console.error(`Error deleting ${originalTarget.type}:`, error); showToast(`Failed to delete ${originalTarget.type}.`, 'error'); } finally { if (originalTarget.type !== 'recording') { if(confirmDeleteBtn) { confirmDeleteBtn.textContent = originalButtonText; confirmDeleteBtn.disabled = false; } document.getElementById('cancelDeleteBtn')?.removeAttribute('disabled'); deleteTarget = null; } } }); } else { console.error("Confirm Delete Button not found during init!"); }
             if(cameraListContainer) { cameraListContainer.addEventListener('click', (event) => { const recordButton = event.target.closest('.camera-action-btn.record'); const motionButton = event.target.closest('.camera-action-btn.motion-detection'); const cameraItem = event.target.closest('.camera-item'); if (recordButton && cameraItem && !recordButton.disabled) { event.stopPropagation(); const camId = cameraItem.dataset.cameraId; if (camId) toggleRecording(camId); else console.warn("Record button missing camera ID on parent"); } else if (motionButton && cameraItem) { event.stopPropagation(); const camId = cameraItem.dataset.cameraId; const cam = camerasData.all.find(c => c.id === camId); if(cam) { currentEditCameraId = cam.id; openSettingsModal(cam); } else { console.warn("Motion button camera not found", camId); } } }); } else { console.error("Camera List Container not found"); }
             if(cameraControls) { cameraControls.addEventListener('click', (event) => { const btn = event.target.closest('button[data-action]'); if (btn) performCameraAction(btn.dataset.action); }); cameraControls.addEventListener('touchmove', e => e.preventDefault(), { passive: false }); } else { console.warn("Camera Controls Container not found"); }
             if(protocolSelector) { protocolSelector.addEventListener('change', (event) => { if (currentCameraData && document.getElementById('cameraPage')?.style.transform === 'translateX(0%)') { currentStreamProtocol = event.target.value; const wrapper = document.getElementById('cameraPage')?.querySelector('.camera-feed .video-wrapper'); if (wrapper) { const cameraFeed = wrapper.parentElement; cameraFeed?.classList.add('loading'); stopMotionDetection(currentCameraData.id); if(wrapper.cleanupStream) { try { wrapper.cleanupStream();} catch(e){}} wrapper.innerHTML = ''; streamRetryCount = 0; setTimeout(() => { const cameraPageActive = document.getElementById('cameraPage')?.style.transform === 'translateX(0%)'; if(cameraPageActive && currentCameraData) { cameraFeed?.classList.remove('loading'); displayLiveCameraFeed(currentCameraData, wrapper); } }, 50); } } }); } else { console.warn("Protocol Selector not found"); }
             if(retryStreamBtn) retryStreamBtn.addEventListener('click', () => { if (currentCameraData && document.getElementById('cameraPage')?.style.transform === 'translateX(0%)') { const wrapper = document.getElementById('cameraPage')?.querySelector('.camera-feed .video-wrapper'); const cameraFeed = wrapper?.parentElement; if (wrapper && cameraFeed) { streamErrorOverlay?.classList.remove('active'); cameraFeed.classList.add('loading'); stopMotionDetection(currentCameraData.id); if(wrapper.cleanupStream) { try {wrapper.cleanupStream();} catch(e){}} wrapper.innerHTML = ''; streamRetryCount = 0; setTimeout(() => { const cameraPageActive = document.getElementById('cameraPage')?.style.transform === 'translateX(0%)'; if(cameraPageActive && currentCameraData) { cameraFeed.classList.remove('loading'); displayLiveCameraFeed(currentCameraData, wrapper); } }, 50); } } }); else console.warn("Retry Stream button not found");
             if(dismissStreamErrorBtn && streamErrorOverlay) dismissStreamErrorBtn.addEventListener('click', () => streamErrorOverlay.classList.remove('active')); else console.warn("Dismiss Stream Error button or overlay not found");
             if(cameraSearchInput) { cameraSearchInput.addEventListener('input', applyCameraSearchFilter); } else { console.warn("Camera search input not found"); }
             if(recordingSearchInput) { recordingSearchInput.addEventListener('input', applyRecordingSearchFilter); } else { console.warn("Recording search input not found"); }
             if(playbackSpeedControls && playbackVideo) { playbackSpeedControls.addEventListener('click', (e) => { const speedButton = e.target.closest('button[data-speed]'); if (speedButton) { const speed = parseFloat(speedButton.dataset.speed); if (!isNaN(speed)) { playbackVideo.playbackRate = speed; playbackSpeedControls.querySelectorAll('button').forEach(btn => btn.classList.remove('active-speed')); speedButton.classList.add('active-speed'); } } }); } else { console.warn("Playback speed controls or video element not found"); }

             // Global Listeners
             document.addEventListener('keydown', handleKeyboardNavigation);
             document.addEventListener('visibilitychange', () => { if (document.hidden) { Object.keys(motionDetectionIntervals).forEach(stopMotionDetection); } else { const cameraPageActive = document.getElementById('cameraPage')?.style.transform === 'translateX(0%)'; if (currentCameraData?.motionDetectionEnabled && cameraPageActive) { const liveVideo = document.getElementById('cameraPage')?.querySelector('.camera-feed video'); if (liveVideo && !liveVideo.error && liveVideo.readyState >= 3 && !liveVideo.paused) { startMotionDetection(currentCameraData, liveVideo); } } applyCameraSearchFilter(); /* Refresh list on visibility change in case CORS state changed */ } });

             // Swipe Listeners
             const swipeOptions = { passive: true };
             if(cameraPage) { cameraPage.addEventListener('touchstart', handleTouchStart, swipeOptions); cameraPage.addEventListener('touchmove', handleTouchMove, swipeOptions); cameraPage.addEventListener('touchend', handleTouchEnd, swipeOptions); cameraPage.addEventListener('touchcancel', handleTouchEnd, swipeOptions); } else { console.error("Camera Page element not found for swipe listeners"); }
             if(recordingsPage) { recordingsPage.addEventListener('touchstart', handleTouchStart, swipeOptions); recordingsPage.addEventListener('touchmove', handleTouchMove, swipeOptions); recordingsPage.addEventListener('touchend', handleTouchEnd, swipeOptions); recordingsPage.addEventListener('touchcancel', handleTouchEnd, swipeOptions); } else { console.error("Recordings Page element not found for swipe listeners"); }

             // Initial UI setup
             addAnimationToCameraButtons();
             addTabEventListeners();

             console.log("App Initialized.");
        } // End initializeApp

        // Start the application
        initializeApp();

    }); // End DOMContentLoaded
    </script>
</body>
</html>
